if(m <= M1) {
return(alphas[m]*dnorm(xx, mean=means[m], sd=sqrt(vars[m])))
} else {
return(alphas[m]*my_dt(xx, mean=means[m], var=vars[m], df=dfs[m - M1]))
}
}
# The model density
mod_dens_f <- function(xx) {
rowSums(vapply(1:M, function(m) reg_dens(m, xx), numeric(length(xx))))
}
# Densities and figure bounds
data_dens <- density(data)
mod_mean <- gsmar$uncond_moments$uncond_mean
mod_sd <- sqrt(gsmar$uncond_moments$uncond_var)
x0 <- min(mod_mean - 3*mod_sd, min(data_dens$x))
x1 <- max(mod_mean + 3*mod_sd, max(data_dens$x))
xpp <- seq(from=x0, to=x1, length.out=500)
mod_dens <- mod_dens_f(xpp)
y0 <- 0
y1 <- max(c(data_dens$y, mod_dens))
# Plot the densities
plot(x=data_dens$x, y=data_dens$y, xlim=c(x0, x1), ylim=c(y0, y1), main="Density",
ylab="", xlab="", cex.axis=0.8, font.axis=2, type="l")
lines(x=xpp, y=mod_dens, type="l", lty=2, lwd=2, col="darkgrey")
for(m in 1:M) {
lines(x=xpp, y=reg_dens(m, xx=xpp), type="l", lty=3, col=colpal_mw[m])
}
}
invisible(gsmar)
}
if(gsmarpred$pi_type == "two-sided") {
ts1_lapply <- function(pred_ints, mix=FALSE, m) lapply(1:(length(q)/2), function(i1) make_ts(pred_ints[,i1], mix, m)) # Lower bounds
ts2_lapply <- function(pred_ints, mix=FALSE, m) lapply((length(q)/2 + 1):length(q), function(i1) make_ts(pred_ints[,i1], mix, m)) # Upper bounds
ints1 <- gsmarpred$pred_ints
ints1_mix <- gsmarpred$mix_pred_ints
} else {
what_to_rep <- ifelse(gsmarpred$pi_type == "upper", round(min(all_val)) - 3, round(max(all_val)) + 3) # Otherwise "lower" or "none"
what_to_rep_mix <- ifelse(gsmarpred$pi_type == "upper", 0, 1)
ts1_lapply <- function(pred_ints, mix=FALSE, m) lapply(seq_along(q), function(i1) make_ts(pred_ints[,i1], mix, m)[-1]) # Upper or lower graphical device box bound (redundant argument)
ts2_lapply <- function(pred_ints, mix=FALSE, m) lapply(seq_along(q), function(i1) make_ts(pred_ints[,i1], mix, m)) # Make upper or lower prediction bound
#  ts0 <- rep(what_to_rep, times=length(ts_pred))
#  ts1 <- lapply(seq_along(q), function(i1) make_ts(ts0)[-1]) # Upper or lower graphical device box bound
#  ts2 <- lapply(seq_along(q), function(i1) make_ts(gsmarpred$pred_ints[,i1])) # Upper or lower prediction bound
ints1 <- matrix(rep(what_to_rep, times=length(q)*length(ts_pred)), ncol=length(q))
ints1_mix <- array(rep(what_to_rep_mix, times=length(ts_pred)*length(q)*M), dim=c(length(ts_pred), length(q), M))
}
# Create the ts objects for confidence intervals
ts1 <- ts1_lapply(ints1)
ts2 <- ts2_lapply(gsmarpred$pred_ints)
if(mix_weights) {
ts1_mw <- vector(mode="list", length=M) # Sublist for each regime
ts2_mw <- vector(mode="list", length=M)
for(m in 1:M) {
ts1_mw[[m]] <- ts1_lapply(ints1_mix[, , m], mix=TRUE, m=m)
ts2_mw[[m]] <- ts2_lapply(gsmarpred$mix_pred_ints[, , m], mix=TRUE, m=m)
}
}
ts.plot(ts_dat, ts_pred, gpars=list(col=c("black", "blue"), lty=1:2,
ylim=c(round(min(all_val)) - 1,
round(max(all_val)) + 1),
main=paste("Forecast", gsmarpred$n_ahead, "steps ahead")))
if(add_grid) grid(...)
# Draw the prediction intervals
draw_poly <- function(ts1_or_ts2, pred_ts, col) polygon(x=c(t0, rev(t0)), y=c(ts1_or_ts2, rev(pred_ts)), col=col, border=NA)
col_pred <- grDevices::rgb(0, 0, 1, 0.2)
if(gsmarpred$pi_type %in% c("two-sided", "upper", "lower")) {
for(i1 in 1:length(gsmarpred$pi)) { # Go through the prediction intervals
draw_poly(ts1[[i1]], ts_pred, col=col_pred)
draw_poly(ts2[[i1]], ts_pred, col=col_pred)
}
}
# Plot mixing weight forecasts
if(mix_weights) {
# Point forecasts
colpal_mw <- grDevices::colorRampPalette(c("blue", "turquoise1", "green", "red"))(M)
colpal_mw2 <- grDevices::adjustcolor(colpal_mw, alpha.f=0.5)
mix_ts <- ts(gsmarpred$gsmar$mixing_weights[(n_mix - nt + 1):n_mix,], start=time(data)[n_obs - nt + 1],
frequency=frequency(data))
mix_pred_ts <- ts(rbind(mix_ts[nrow(mix_ts),], gsmarpred$mix_pred), start=time(data)[n_obs], frequency=frequency(data))
ts.plot(mix_ts, mix_pred_ts, gpars=list(col=c(colpal_mw2, colpal_mw), ylim=c(0, 1), lty=c(rep(1, M), rep(2, M))))
legend("topleft", legend=paste0("regime ", 1:M), bty="n", col=colpal_mw, lty=1, lwd=2,
text.font=2, cex=0.65, x.intersp=0.5, y.intersp=1)
if(add_grid) grid(...)
# Individual prediction intervals as for the mixing weights
colpal_mw3 <- grDevices::adjustcolor(colpal_mw, alpha.f=0.2)
if(gsmarpred$pi_type %in% c("two-sided", "upper", "lower")) {
for(m in 1:M) { # Go through regimes
for(i1 in 1:length(gsmarpred$pi)) { # Go through the prediction intervals
draw_poly(ts1_mw[[m]][[i1]], mix_pred_ts[, m], col=colpal_mw3[m])
draw_poly(ts2_mw[[m]][[i1]], mix_pred_ts[, m], col=colpal_mw3[m])
}
}
}
}
# Point forecasts
colpal_mw <- grDevices::colorRampPalette(c("blue", "turquoise1", "green", "red"))(M)
colpal_mw2 <- grDevices::adjustcolor(colpal_mw, alpha.f=0.5)
mix_ts <- ts(gsmarpred$gsmar$mixing_weights[(n_mix - nt + 1):n_mix,], start=time(data)[n_obs - nt + 1],
frequency=frequency(data))
mix_pred_ts <- ts(rbind(mix_ts[nrow(mix_ts),], gsmarpred$mix_pred), start=time(data)[n_obs], frequency=frequency(data))
ts.plot(mix_ts, mix_pred_ts, gpars=list(col=c(colpal_mw2, colpal_mw), ylim=c(0, 1), lty=c(rep(1, M), rep(2, M))))
legend("topleft", legend=paste0("regime ", 1:M), bty="n", col=colpal_mw, lty=1, lwd=2,
text.font=2, cex=0.65, x.intersp=0.5, y.intersp=1)
if(add_grid) grid(...)
# Individual prediction intervals as for the mixing weights
colpal_mw3 <- grDevices::adjustcolor(colpal_mw, alpha.f=0.2)
if(gsmarpred$pi_type %in% c("two-sided", "upper", "lower")) {
for(m in 1:M) { # Go through regimes
for(i1 in 1:length(gsmarpred$pi)) { # Go through the prediction intervals
draw_poly(ts1_mw[[m]][[i1]], mix_pred_ts[, m], col=colpal_mw3[m])
draw_poly(ts2_mw[[m]][[i1]], mix_pred_ts[, m], col=colpal_mw3[m])
}
}
}
predict(fit43gs, pi_type="uppoer", nsimu=200, n_ahead=10)
predict(fit43gs, pi_type="upper", nsimu=200, n_ahead=10)
devtools::load_all()
predict(fit43gs, pi_type="upper", nsimu=200, n_ahead=10)
predict(fit43gs, pi_type="lower", nsimu=200, n_ahead=10)
predict(fit43gs, pi_type="lower", nsimu=200, n_ahead=10, ci=c(99, 0.8, 0.5))
predict(fit43gs, pi_type="lower", nsimu=200, n_ahead=10, pi=c(99, 0.8, 0.5))
predict(fit43gs, pi_type="lower", nsimu=200, n_ahead=10, pi=c(0.99, 0.8, 0.5))
predict(fit43gs, pi_type="uppoer", nsimu=200, n_ahead=10, pi=c(0.99, 0.8, 0.5))
predict(fit43gs, pi_type="upper", nsimu=200, n_ahead=10, pi=c(0.99, 0.8, 0.5))
predict(fit43gs, pred_type="cond_mean", plotRes=FALSE)
predict(fit43gs, pred_type="cond_mean", plotRes=FALSE)
predict(fit43gs, n_ahead=30, pi=0.8)
devtools::load_all()
devtools::document()
predict(fit43gs, n_ahead=10)
predict(fit43gs, n_ahead=10, nsimu=200)
predict(fit43gs, n_ahead=10, nsimu=200)
predict(fit43gs, n_ahead=10, nsimu=200, pi=c(0.8, 0.90))
predict(fit43gs, n_ahead=10, nsimu=200, pi=c(0.8, 0.90), pi_type="upper")
predict(fit43gs, n_ahead=10, nsimu=200, pi=c(0.8, 0.90), pi_type="lower")
predict(fit43gs, n_ahead=10, nsimu=200, pi=c(0.8, 0.90), pred_type = "mean")
predict(fit43gs, n_ahead=10, nsimu=200, pi=c(0.8, 0.90), pred_type = "cond_mean")
dev.off()
predict(fit43gs, n_ahead=10, nsimu=200, pi=c(0.8, 0.90), pred_type = "mean")
predict(fit43gs, n_ahead=10, nsimu=200, pi=c(0.8, 0.90), pred_type = "cond_mean")
predict(fit43gs, n_ahead=10, nsimu=200, pi=c(0.8, 0.90), pred_type = "mean")
setwd("~/Documents/uGMAR")
params12 <- c(1.0, 0.9, 0.25, 4.5, 0.7, 3.0, 0.8)
gmar12 <- GSMAR(data=VIX, p=1, M=2, params=params12, model="GMAR")
devtools::load_all()
devtools::document()
gmar12 <- GSMAR(data=VIX, p=1, M=2, params=params12, model="GMAR")
set.seed(1); pred12 <- predict.gsmar(gmar12, n_ahead=1, nsimu=50, plotRes=FALSE, pred_type="mean")
pred12
pred12$pred_ints
devtools::load_all()
devtools::test()
devtools::test()
pred12$pred_ints
pred12$pred_ints[2]
devtools::build()
setwd("~/uGMAR")
devtools::load_all()
devtools::document()
fit11t <- fitGSMAR(logVIX, 1, 1, model="StMAR", ncores=1, ncalls=1)
fit12 <- fitGSMAR(data=logVIX, p=1, M=2, model="GMAR")
predict(fit11t, n_ahead=10, pi_type="upper", pi=0.9)
?apply
gsmar <- fit11t
n_ahead=5
nsimu=500
pred_type="median"
devtools::document()
pi_type="two-sided"
pi=c(0.95, 0.8)
plotRes=TRUE
mix_weights=TRUE
nt=50
data <- gsmar$data
n_obs <- length(data)
p <- gsmar$model$p
M <- gsmar$model$M
params <- gsmar$params
model <- gsmar$model$model
restricted <- gsmar$model$restricted
constraints <- gsmar$model$constraints
# Simulations
sim <- simulateGSMAR(gsmar, nsimu=n_ahead, initvalues=data, ntimes=nsimu, drop=FALSE)
sample <- sim$sample
alpha_mt <- sim$mixing_weights
# Point forecasts
myFUN <- ifelse(pred_type == "mean", mean, median)
pred <- apply(sample, 1, FUN=myFUN)
mix_pred <- apply(alpha_mt, MARGIN=1:2, FUN=mean)
# Prediction intervals
if(pi_type == "upper") {
q_tocalc <- pi
} else if(pi_type == "lower") {
q_tocalc <- 1 - pi
} else if(pi_type == "two-sided") {
lower <- (1 - pi)/2
upper <- rev(1 - lower)
q_tocalc <- c(lower, upper)
} else {  # If pi_type == "none"
q_tocalc <- numeric(0)
pi <- NULL
}
q_tocalc <- sort(q_tocalc, decreasing=FALSE)
pred_ints <- t(apply(sample, 1, FUN=quantile, probs=q_tocalc))
mix_pred_ints <- apply(alpha_mt, MARGIN=1:2, FUN=quantile, probs=q_tocalc)
mix_pred_ints
aperm(mix_pred_ints, perm=c(2, 1, 3))
mix_pred_ints <- aperm(mix_pred_ints, perm=c(2, 1, 3)) # So that for each [, , i1] the dimensions match with point forecasts
mix_pred_ints
pred_ints
colnames(alpha_mt) <- vapply(1:gsmar$model$M, function(m) paste("regime", m), character(1))
# Point forecasts
myFUN <- ifelse(pred_type == "mean", mean, median)
pred <- apply(sample, 1, FUN=myFUN)
mix_pred <- apply(alpha_mt, MARGIN=1:2, FUN=mean)
# Prediction intervals
if(pi_type == "upper") {
q_tocalc <- pi
} else if(pi_type == "lower") {
q_tocalc <- 1 - pi
} else if(pi_type == "two-sided") {
lower <- (1 - pi)/2
upper <- rev(1 - lower)
q_tocalc <- c(lower, upper)
} else {  # If pi_type == "none"
q_tocalc <- numeric(0)
pi <- NULL
}
q_tocalc <- sort(q_tocalc, decreasing=FALSE)
pred_ints <- t(apply(sample, 1, FUN=quantile, probs=q_tocalc))
mix_pred_ints <- apply(alpha_mt, MARGIN=1:2, FUN=quantile, probs=q_tocalc)
mix_pred_ints <- aperm(mix_pred_ints, perm=c(2, 1, 3)) # So that for each [, , i1] the dimensions match with point forecasts
mix_pred_ints
predict(fit11, n_ahead=5, plotRes=FALSE)
predict(fit11t, n_ahead=5, plotRes=FALSE)
predict(fit11t, n_ahead=5, plotRes=TRUE)
devtools::load_all()
predict(fit11t, n_ahead=5, plotRes=TRUE)
devtools::document()
devtools::load_all()
predict(fit11t, n_ahead=5, plotRes=TRUE)
predict(fit12, n_ahead=5, plotRes=TRUE)
predict(fit12, n_ahead=5, pi_type="lower")
predict(fit12, n_ahead=5, pi_type="upper")
predict(fit12, n_ahead=5, pi_type="none")
devtools::load_all()
predict(fit12, n_ahead=5, pi_type="none")
predict(fit12, n_ahead=5, pi_type="none")$pred_ints
predict(fit12, n_ahead=5, pi_type="none")$mix_pred_ints
predict(fit11, n_ahead=5, pi_type="none")
predict(fit11t, n_ahead=5, pi_type="none", nsimu=100)
predict(fit11t, n_ahead=5, pi_type="none", pred_type="cond_mean" nsimu=100)
predict(fit11t, n_ahead=5, pi_type="none", pred_type="cond_mean", nsimu=100)
predict(fit22, n_ahead=5, pi_type="none", pred_type="cond_mean", nsimu=100)
predict(fit12, n_ahead=5, pi_type="none", pred_type="cond_mean", nsimu=100)
predict(fit12, n_ahead=5, pi=c(0.90, 0.60, 0.50), nsimu=100)
predict(fit12, n_ahead=5, pi=c(0.90, 0.60, 0.50), nsimu=100)$mix_pred
predict(fit12, n_ahead=5, pi=c(0.90, 0.60, 0.50), nsimu=100)$mix_pred_ints
devtools::document()
devtools::test()
params12 <- c(1.0, 0.9, 0.25, 4.5, 0.7, 3.0, 0.8)
gmar12 <- GSMAR(data=VIX, p=1, M=2, params=params12, model="GMAR")
set.seed(1); pred12 <- predict.gsmar(gmar12, n_ahead=1, nsimu=50, pi=c(0.90, 0.80), plotRes=FALSE, pred_type="mean")
set.seed(1); pred12_0 <- predict.gsmar(gmar12, n_ahead=1, nsimu=1, pi_type="none", plotRes=FALSE, pred_type="mean")
pred12$pred
pred12_0$pred
params23 <- c(2.7, 0.8, -0.06, 0.3, 3.5, 0.8, -0.07, 2.6, 7.2, 0.3, -0.01, 0.1, 0.6, 0.25)
gmar23 <- GSMAR(data=VIX, p=2, M=3, params=params23, model="GMAR")
set.seed(2); pred23_0 <- predict.gsmar(gmar23, n_ahead=1, nsimu=1, plotRes=FALSE, pred_type="cond_mean")
pred23_0$pred
pred12$pred_ints
pred12$pred_ints[2]
pred12$pred_ints[1]
pred12$pred_ints[3]
pred12$pred_ints[1]
devtools::load_all()
devtools::test()
devtools::document()
setwd("~/uGMAR")
devtools::load_all()
fit12 <- fitGSMAR(data=logVIX, p=1, M=2, model="GMAR")
predict(fit12, n_ahead=10, pi=c(0.95, 0.8))
predict(fit12, n_ahead=10, pi=c(0.95, 0.8), nsimu=200)
predict(fit12, n_ahead=10, pi=c(0.95, 0.8), nsimu=1)
predict(fit12, n_ahead=10, pi=c(0.95, 0.8), nsimu=10)
predict(fit12, n_ahead=10, pi=c(0.95), nsimu=10)
predict(fit12, n_ahead=10, pi=c(0.95), nsimu=10, pi_type="upper")
gmvar <- fit12
n_ahead=10
pi=0.9
q_tocalc=0.9
q_tocalc <- sort(q_tocalc, decreasing=FALSE)
pred_ints <- t(apply(sample, 1, FUN=quantile, probs=q_tocalc))
gsmar <- fit12
# Simulations
sim <- simulateGSMAR(gsmar, nsimu=n_ahead, initvalues=data, ntimes=nsimu, drop=FALSE)
nsimu=10
data
data <- fit12$dataq
data <- fit12$data
# Simulations
sim <- simulateGSMAR(gsmar, nsimu=n_ahead, initvalues=data, ntimes=nsimu, drop=FALSE)
sample <- sim$sample
alpha_mt <- sim$mixing_weights
colnames(alpha_mt) <- vapply(1:gsmar$model$M, function(m) paste("regime", m), character(1))
# Point forecasts
myFUN <- ifelse(pred_type == "mean", mean, median)
pred <- apply(sample, 1, FUN=myFUN)
mix_pred <- apply(alpha_mt, MARGIN=1:2, FUN=mean)
# Point forecasts
myFUN <- ifelse(pred_type == "mean", mean, median)
pred_type="median"
# Point forecasts
myFUN <- ifelse(pred_type == "mean", mean, median)
pred <- apply(sample, 1, FUN=myFUN)
mix_pred <- apply(alpha_mt, MARGIN=1:2, FUN=mean)
pred
mix_pred
q_tocalc <- sort(q_tocalc, decreasing=FALSE)
pred_ints <- t(apply(sample, 1, FUN=quantile, probs=q_tocalc))
q_tocalc <- 0.9
pred_ints <- t(apply(sample, 1, FUN=quantile, probs=q_tocalc))
pred_ints
apply(sample, 1, FUN=quantile, probs=q_tocalc)
sample
n_ahead
n_ahead <- 3
# Simulations
sim <- simulateGSMAR(gsmar, nsimu=n_ahead, initvalues=data, ntimes=nsimu, drop=FALSE)
sample <- sim$sample
alpha_mt <- sim$mixing_weights
colnames(alpha_mt) <- vapply(1:gsmar$model$M, function(m) paste("regime", m), character(1))
# Point forecasts
myFUN <- ifelse(pred_type == "mean", mean, median)
pred <- apply(sample, 1, FUN=myFUN)
mix_pred <- apply(alpha_mt, MARGIN=1:2, FUN=mean)
q_tocalc <- sort(q_tocalc, decreasing=FALSE)
pred_ints <- t(apply(sample, 1, FUN=quantile, probs=q_tocalc))
pred_ints
apply(sample, 1, FUN=quantile, probs=q_tocalc)
apply(sample, 1, FUN=quantile, probs=q_tocalc)
apply(sample, 1, FUN=quantile, probs=c(0.9, 0.8))
t(apply(sample, 1, FUN=quantile, probs=c(0.9, 0.8)))
apply(sample, 1, FUN=quantile, probs=q_tocalc)
as.matrix(apply(sample, 1, FUN=quantile, probs=q_tocalc))
colnames(pred_ints) <- q_tocalc
pred_ints <- as.matrix(apply(sample, 1, FUN=quantile, probs=q_tocalc))
colnames(pred_ints)
colnames(pred_ints) <- q_tocalc
pred_ints
apply(alpha_mt, MARGIN=1:2, FUN=quantile, probs=q_tocalc)
mix_pred_ints <- array(apply(alpha_mt, MARGIN=1:2, FUN=quantile, probs=q_tocalc),
dim=c(n_ahead, M, length(q_tocalc), dimnames=c(NULL, colnames(alpha_mt), q_tocalc))
} else {
pred_ints <- t(apply(sample, 1, FUN=quantile, probs=q_tocalc))
mix_pred_ints <- apply(alpha_mt, MARGIN=1:2, FUN=quantile, probs=q_tocalc)
}
if(pi_type != "none") {
mix_pred_ints <- aperm(mix_pred_ints, perm=c(2, 1, 3)) # So that for each [, , i1] the dimensions match with point forecasts
}
}
ret <- structure(list(gsmar=gsmar,
pred=pred,
pred_ints=pred_ints,
mix_pred=mix_pred,
mix_pred_ints=mix_pred_ints,
n_ahead=n_ahead,
nsimu=nsimu,
pi=pi,
pi_type=pi_type,
pred_type=pred_type,
q=q_tocalc,
mix_weights=mix_weights),
class="gsmarpred")
if(plotRes) plot.gsmarpred(x=ret, nt=nt, mix_weights=mix_weights, ...)
ret
}
mix_pred_ints <- array(apply(alpha_mt, MARGIN=1:2, FUN=quantile, probs=q_tocalc),
dim=c(n_ahead, M, length(q_tocalc)), dimnames=c(NULL, colnames(alpha_mt), q_tocalc))
mix_pred_ints <- array(apply(alpha_mt, MARGIN=1:2, FUN=quantile, probs=q_tocalc),
dim=c(n_ahead, gsmar$model$M, length(q_tocalc)), dimnames=c(NULL, colnames(alpha_mt), q_tocalc))
mix_pred_ints <- array(apply(alpha_mt, MARGIN=1:2, FUN=quantile, probs=q_tocalc),
dim=c(n_ahead, gsmar$model$M, length(q_tocalc)), dimnames=list(NULL, colnames(alpha_mt), q_tocalc))
mix_pred_ints
aperm(mix_pred_ints, perm=c(2, 1, 3))
pred_ints
pred_ints <- apply(sample, 1, FUN=quantile, probs=q_tocalc)
mix_pred_ints <- apply(alpha_mt, MARGIN=1:2, FUN=quantile, probs=q_tocalc)
as.matrix(pred_ints)
mix_pred_ints <- array(mix_pred_ints, dim=c(n_ahead, gsmar$model$M, length(q_tocalc)), dimnames=list(NULL, colnames(alpha_mt), q_tocalc))
mix_pred_ints
q_tocalc <- c(0.9, 0.8)
q_tocalc <- sort(q_tocalc, decreasing=FALSE)
pred_ints <- apply(sample, 1, FUN=quantile, probs=q_tocalc)
mix_pred_ints <- apply(alpha_mt, MARGIN=1:2, FUN=quantile, probs=q_tocalc)
mix_pred_ints
mix_pred_ints <- aperm(mix_pred_ints, perm=c(2, 1, 3)) # So that for each [, , i1] the dimensions match with point forecasts
mix_pred_ints
pred_ints <- t(pred_ints)
pred_ints
q_tocalc <- 0.8
q_tocalc <- sort(q_tocalc, decreasing=FALSE)
pred_ints <- apply(sample, 1, FUN=quantile, probs=q_tocalc)
mix_pred_ints <- apply(alpha_mt, MARGIN=1:2, FUN=quantile, probs=q_tocalc)
pred_ints <- as.matrix(pred_ints)
mix_pred_ints
mix_pred_ints <- array(mix_pred_ints, dim=c(n_ahead, gsmar$model$M, length(q_tocalc)), dimnames=list(NULL, colnames(alpha_mt), q_tocalc))
mix_pred_ints
mix_pred_ints <- aperm(mix_pred_ints, perm=c(3, 1, 2))
mix_pred_ints
mix_pred_ints <- apply(alpha_mt, MARGIN=1:2, FUN=quantile, probs=q_tocalc)
mix_pred_ints <- array(mix_pred_ints, dim=c(n_ahead, gsmar$model$M, length(q_tocalc)), dimnames=list(NULL, colnames(alpha_mt), q_tocalc))
mix_pred_ints <- aperm(mix_pred_ints, perm=c(1, 3, 2))
mix_pred_ints
devtools::load_all()
predict(fit12, n_ahead=3)
predict(fit12, n_ahead=3, pi_type="lower")
predict(fit12, n_ahead=3, pi_type="lower", pi=0.7)
piFAIL <- predict(fit12, n_ahead=3, pi_type="lower", pi=0.7, plotRes = FALSE)
piOK <- predict(fit12, n_ahead=3, pi_type="lower", pi=c(0.7, 0.8), plotRes = T)
piOK$mix_pred
piFAIL$mix_pred
piFAIL$mix_pred_ints
piOK$mix_pred_ints
piOK$pred_ints
piFAIL$pred_ints
gsmarpred <- piFAIl
gsmarpred <- piFAIL
piFAIL
data <- as.ts(gsmarpred$gsmar$data)
n_obs <- length(data)
q <- gsmarpred$q
M <- sum(gsmarpred$gsmar$model$M)
mix_weights <- gsmarpred$mix_weights & M > 1
mixing_weights <- gsmarpred$gsmar$mixing_weights
n_mix <- nrow(mixing_weights)
# Graphical parameters
old_par <- par(no.readonly=TRUE) # Save old settings
on.exit(par(old_par)) # Restore the settings before quitting
if(mix_weights) {
par(mfrow=c(2, 1), mar=c(2.6, 2.6, 2.6, 2.6))
}
if(missing(nt)) {
nt <- round(length(data)*0.15)
} else {
stopifnot(nt > 0 & nt %% 1 == 0)
if(nt > length(data)) {
warning("nt > length(data); using nt = length(data)")
nt <- length(data)
}
}
nt=20
make_ts <- function(a, mix=FALSE, m) { # a is vector of values; if mix == TRUE, give component m in 1,...,M
last_obs <- ifelse(mix, mixing_weights[n_mix, m], data[n_obs])
ts(c(last_obs, a), start=time(data)[n_obs], frequency=frequency(data))
}
ts_pred <- make_ts(gsmarpred$pred)
ts_dat <- ts(data[(n_obs - nt + 1):n_obs], start=time(data)[n_obs - nt + 1], frequency=frequency(data))
t0 <- time(ts_pred)
all_val <- c(ts_dat, ts_pred, gsmarpred$pred_ints)
if(gsmarpred$pi_type == "two-sided") {
ts1_lapply <- function(pred_ints, mix=FALSE, m) lapply(1:(length(q)/2), function(i1) make_ts(pred_ints[,i1], mix, m)) # Lower bounds
ts2_lapply <- function(pred_ints, mix=FALSE, m) lapply((length(q)/2 + 1):length(q), function(i1) make_ts(pred_ints[,i1], mix, m)) # Upper bounds
ints1 <- gsmarpred$pred_ints
ints1_mix <- gsmarpred$mix_pred_ints
} else {
what_to_rep <- ifelse(gsmarpred$pi_type == "upper", round(min(all_val)) - 3, round(max(all_val)) + 3) # Otherwise "lower" or "none"
what_to_rep_mix <- ifelse(gsmarpred$pi_type == "upper", 0, 1)
ts1_lapply <- function(pred_ints, mix=FALSE, m) lapply(seq_along(q), function(i1) make_ts(pred_ints[,i1], mix, m)[-1]) # Upper or lower graphical device box bound (redundant argument)
ts2_lapply <- function(pred_ints, mix=FALSE, m) lapply(seq_along(q), function(i1) make_ts(pred_ints[,i1], mix, m)) # Make upper or lower prediction bound
ints1 <- matrix(rep(what_to_rep, times=length(q)*length(ts_pred)), ncol=length(q))
ints1_mix <- array(rep(what_to_rep_mix, times=length(ts_pred)*length(q)*M), dim=c(length(ts_pred), length(q), M))
}
# Create the ts objects for confidence intervals
ts1 <- ts1_lapply(ints1)
ts2 <- ts2_lapply(gsmarpred$pred_ints)
if(mix_weights) {
ts1_mw <- vector(mode="list", length=M) # Sublist for each regime
ts2_mw <- vector(mode="list", length=M)
for(m in 1:M) {
ts1_mw[[m]] <- ts1_lapply(ints1_mix[, , m], mix=TRUE, m=m)
ts2_mw[[m]] <- ts2_lapply(gsmarpred$mix_pred_ints[, , m], mix=TRUE, m=m)
}
}
ints1_mix
m=1
ts1_mw <- vector(mode="list", length=M) # Sublist for each regime
ts2_mw <- vector(mode="list", length=M)
ts1_mw[[m]] <- ts1_lapply(ints1_mix[, , m], mix=TRUE, m=m)
ints1_mix[, , m]
ints1_mix[, , m, drop=FALSE]
ts2_lapply(gsmarpred$mix_pred_ints[, , m,], mix=TRUE, m=m)
ts1_mw[[m]] <- ts1_lapply(as.matrix(ints1_mix[, , m]), mix=TRUE, m=m)
ts2_mw[[m]] <- ts2_lapply(as.matrix(gsmarpred$mix_pred_ints[, , m,]), mix=TRUE, m=m)
ts2_mw[[m]] <- ts2_lapply(as.matrix(gsmarpred$mix_pred_ints[, , m]), mix=TRUE, m=m)
devtools::load_all()
piFAIL <- predict(fit12, n_ahead=3, pi_type="lower", pi=0.7, plotRes = FALSE)
plot(piFAIL)
piFAIL <- predict(fit12, n_ahead=1, pi_type="lower", pi=0.7)
fit11 <- fitGSMAR(datam p=1, M=1, ncalls=1)
fit11 <- fitGSMAR(data, p=1, M=1, ncalls=1)
predict(fit11, n_ahead=1, nsimu=1, pi_type="upper", pi=0.8)
dev.off
dev.off()
predict(fit11, n_ahead=1, nsimu=1, pi_type="upper", pi=0.8)
devtools::test()
devtools::document()
?isStationary_int
devtools::document()
plot(fit12)
devtools::document()
predict(fit12, n_ahead=10)
