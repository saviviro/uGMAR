abline(v=1987, col="blue", lty=2)
1/12
1-1/12
abline(v=1986.9166667, col="blue", lty=2)
1-1/12
1-3/12
abline(v=1986.75, col="green", lty=3)
abline(v=1990.25, col="green", lty=3)
abline(v=1990.08333333, col="green4", lty=1)
cumsum(FEDFUNDS)
ts(cumsum(FEDFUNDS), start=c(1954, 7), frequency=12)
FEDFUNDS
abline(v=2008, col="red")
mods2[[5]]
summary(mods2[[5]])
summary(mods3[[5]])
print(mod53$params, digits=3)
print(mod53$params, digits=2)
print(round(mod53$params, 3))
qrt53
set.seed(0); qrt53tmp <- quantileResidualTests(mod53, nsimu=500000, lagsAC=c(1, 3, 6, 12))
devtools::install_github('saviviro/uGMAR')
devtools::install_github('saviviro/uGMAR')
devtools::install_github('hadley/tidyverse')
remove.packages("uGMAR")
set.seed(0); qrt53tmp <- quantileResidualTests(mod53, nsimu=500000, lagsAC=c(1, 3, 6, 12))
set.seed(42); qrt53tmp <- quantileResidualTests(mod53, nsimu=500000, lagsAC=c(1, 3, 6, 12))
rm(qrt43tmp)
rm(qrt53tmp)
?environment
devtools::load_all()
fitGSMAR(logVIX, 1, c(1, 1), model="G-StMAR", restricted=TRUE)
fitGSMAR(logVIX, 1, c(1, 1), model="G-StMAR", restricted=TRUE)
fitGSMAR(logVIX, 1, c(1, 1), model="G-StMAR", restricted=TRUE)
devtools::load_all()
devtools::load_all()
fitGSMAR(logVIX, 1, c(1, 1), model="G-StMAR", restricted=TRUE)
devtools::load_all()
fitGSMAR(logVIX, 1, c(1, 1), model="G-StMAR", restricted=TRUE)
mods2[[5]]
mods3[[5]]
qrt54g
mod53$uncond_moments
summary(mod53)
rm(ararch)
cranlogs::cran_downloads("uGMAR", when="last-month")
cranlogs::cran_downloads("gmvarkit", when="last-month")
mean(cranlogs::cran_downloads("gmvarkit", when="last-month")$count)
mean(cranlogs::cran_downloads("uGMAR", when="last-month")$count)
load("\\\\ad.helsinki.fi/home/s/saviviro/Desktop/GSTMARartikkeli/empexample_env")
setwd("~/uGMAR")
devtools::load_all()
install.packages("rlang")
devtools::load_all()
mod52
summary(mod52, digits=3)
summary(mod52, digits=5)
par(mforw=c(2, 1))
par(mfor=c(2, 1))
par(mrow=c(2, 1))
par(mfrow=c(2, 1))
plot(TBFF, type="n", main="", ylab="", xlab="", xaxt="n", yaxt="n")
abline(h=0, col="grey", lty=2)
lines(TBFF)
axis(side=2, col.axis="black", col.ticks="black", col="black", lty=1, font=2, cex.axis=0.8)
times <- time(USREC)
froms <- times[vapply(2:length(USREC), function(i1) ifelse((USREC[i1] == 1 & USREC[i1-1] == 0), TRUE, FALSE), logical(1))]
tos <- times[vapply(2:length(USREC), function(i1) ifelse((USREC[i1] == 1 & USREC[i1+1] == 0), TRUE, FALSE), logical(1))]
for(i1 in 1:length(tos)) draw_poly(from=froms[i1], to=tos[i1])
# Mixing weights plot
cols <- c("red3", "green3", "blue3")
pick_alphas(p=5, M=c(1, 2), params=mod53$params, model="G-StMAR")
plot(ts(c(rep(NA, times=5), mod53$mixing_weights[,1]/0.04281051), start=c(1954, 7), frequency=12), type="l", col=cols[1], ylim=c(0, 1), lty=3, ylab=NA, xaxt="n", yaxt="n")
my_mw <- function(data, p, M, params, model=c("GMAR", "StMAR", "G-StMAR"), restricted=FALSE, constraints=NULL,
conditional=TRUE, parametrization=c("intercept", "mean"), boundaries=TRUE, checks=TRUE,
to_return=c("loglik", "mw", "mw_tplus1", "loglik_and_mw", "terms", "regime_cmeans", "regime_cvars",
"total_cmeans", "total_cvars", "qresiduals"), minval) {
epsilon <- round(log(.Machine$double.xmin) + 10)
model <- match.arg(model)
parametrization <- match.arg(parametrization)
to_return <- match.arg(to_return)
M_orig <- M
if(model == "G-StMAR") {
M1 <- M[1]
M2 <- M[2]
M <- sum(M)
} else if(model == "GMAR") {
M1 <- M
M2 <- 0
} else { # model == "StMAR
M1 <- 0
M2 <- M
}
# Reform parameters to the "standard form" and collect them
if(checks) checkConstraintMat(p=p, M=M_orig, restricted=restricted, constraints=constraints)
params <- removeAllConstraints(p=p, M=M_orig, params=params, model=model, restricted=restricted, constraints=constraints)
pars <- pick_pars(p=p, M=M_orig, params=params, model=model, restricted=FALSE, constraints=NULL)
alphas <- pick_alphas(p=p, M=M_orig, params=params, model=model, restricted=FALSE, constraints=NULL)
dfs <- pick_dfs(p=p, M=M_orig, params=params, model=model)
sigmas <- pars[p + 2,] # sigma^2
# Return minval if the parameter is outside the parameters space
if(boundaries) {
if(any(pars[p + 2,] <= 0)) {
return(minval)
} else if(M >= 2 & sum(alphas[-M]) >= 1) {
return(minval)
} else if(any(alphas <= 0)) {
return(minval)
} else if(!isStationary_int(p, M, params, restricted=FALSE)) {
return(minval)
}
if(model == "StMAR" | model == "G-StMAR") {
if(any(dfs <= 2 + 1e-8 | dfs > 1e+5)) return(minval)
}
}
if(checks) {
data <- checkAndCorrectData(data=data, p=p)
parameterChecks(p=p, M=M_orig, params=params, model=model, restricted=FALSE, constraints=NULL)
}
n_obs <- length(data)
## Start evaluating the log-likelihood ##
# Unconditional regimewise means, mu_m (KMS 2015, s.250, and MDP 2018, eq.(4))
if(parametrization == "mean") {
mu <- pars[1,]
pars[1,] <- mu*(1 - colSums(pars[2:(p + 1), , drop=FALSE]))
} else {
mu <- pars[1, ]/(1 - colSums(pars[2:(p + 1), , drop=FALSE]))
}
# Observed data: y_(-p+1),...,y_0,y_1,...,y_(n_obs-p). First row denotes vector y_0, i:th row vector y_[i-1] and last row denotes the vector y_T.
Y <- vapply(1:p, function(i1) data[(p - i1 + 1):(n_obs - i1 + 1)], numeric(n_obs - p + 1))
# Calculate inverse Gamma_m (see the covariance matrix Gamma_p in MPS 2018, p.3 - we calculate this for all mixture components using
# the inverse formula in Galbraith and Galbraith 1974). Also, calculate the matrix products in multivariate normal and t-distribution
# densities.
matProd <- matrix(nrow=n_obs - p + 1, ncol=M)
invG <- array(dim=c(p, p, M))
if(p == 1) {
for(i1 in 1:M) {
invG[, , i1] <- (1 - pars[p + 1, i1]^2)/sigmas[i1]
matProd[, i1] <- (Y - mu[i1])*invG[, , i1]*(Y - mu[i1])
}
} else {
for(i1 in 1:M) {
ARcoefs <- pars[2:(p + 1), i1]
U <- diag(1, nrow=p, ncol=p)
V <- diag(ARcoefs[p], nrow=p, ncol=p)
for(i2 in 1:(p - 1)) {
U[(i2 + 1):p, i2] <- -ARcoefs[1:(p - i2)]
V[(i2 + 1):p, i2] <- rev(ARcoefs[i2:(p - 1)])
}
invG[, , i1] <- (crossprod(U, U) - crossprod(V, V))/sigmas[i1]
matProd[, i1] <- rowSums((Y - mu[i1]*rep(1, p))%*%invG[, , i1]*(Y - mu[i1]*rep(1, p)))
}
}
# Calculate the multivariate normal or student's t values (KMS 2015, eq.(7) and MPS 2018, Theorem 1) in log for each vector y_t and for each m=1,..,M.
# First row for initial values \bm{y}_0 (as denoted by KMS 2015) and i:th row for \bm{y}_(i-1). First column for component m=1 and j:th column for m=j.
logmv_values <- matrix(nrow=(n_obs - p + 1), ncol=M)
if(model == "GMAR" | model == "G-StMAR") { # Multinormals
for(i1 in 1:M1) {
detG <- 1/det(as.matrix(invG[, , i1]))
logmv_values[,i1] <- -0.5*p*log(2*base::pi) - 0.5*log(detG) - 0.5*matProd[,i1]
}
}
if(model == "StMAR" | model == "G-StMAR") { # Multistudents
for(i1 in (M1 + 1):M) {
detG <- 1/det(as.matrix(invG[, , i1]))
logC <- lgamma(0.5*(p + dfs[i1 - M1])) - 0.5*p*log(base::pi) - 0.5*p*log(dfs[i1 - M1] - 2) - lgamma(0.5*dfs[i1 - M1])
logmv_values[,i1] <- logC - 0.5*log(detG) - 0.5*(p + dfs[i1 - M1])*log(1 + matProd[,i1]/(dfs[i1 - M1] - 2))
}
}
# Calculate the mixing weights alpha_mt (KMS 2015, eq.(8) and MPS 2018, eq.(11)).
# First row for t=1, second for t=2, and i:th for t=i. First column for m=1, second for m=2 and j:th column for m=j.
if(to_return != "mw_tplus1") {
logmv_values0 <- logmv_values[1:(n_obs - p),] # The last row is not needed because alpha_mt uses vector Y_(t-1)
} else {
logmv_values0 <- logmv_values # The last row is needed for alpha_{m,t+1}
}
if(!is.matrix(logmv_values0)) logmv_values0 <- as.matrix(logmv_values0)
l_0 <- 0 # "The first term" of the exact log-likelihood function (KMS 2015, eq.(12) and MPS 2018, eq.(14))
if(M == 1) { # No need to do calculations is only one regime.
alpha_mt <- as.matrix(rep(1, nrow(logmv_values0)))
if(conditional == FALSE && (to_return == "loglik" | to_return == "loglik_and_mw")) {
l_0 <- logmv_values[1]
}
} else if(any(logmv_values0 < epsilon)) { # Close to zero values handled with package Brobdingnag if needed.
numerators <- lapply(1:M, function(i1) exp(Brobdingnag::as.brob(logmv_values0[,i1]))) # alphas[i1]*Brobdingnag::as.brob(exp(1))^logmv_values0[,i1]
denominator <- Reduce("+", numerators) # For all t=0,...,T
alpha_mt <- vapply(1:M, function(i1) as.numeric(numerators[[i1]]/denominator), numeric(nrow(logmv_values0)))
if(conditional == FALSE && (to_return == "loglik" | to_return == "loglik_and_mw")) {
l_0 <- log(Reduce("+", lapply(1:M, function(i1) numerators[[i1]][1])))
}
} else {
mv_values0 <- exp(logmv_values0)
denominator <- as.vector(mv_values0)
alpha_mt <- (mv_values0/denominator)
if(conditional == FALSE && (to_return == "loglik" | to_return == "loglik_and_mw")) {
l_0 <- log(sum(alphas*mv_values0[1,]))
}
}
if(to_return == "mw" | to_return == "mw_tplus1") {
return(alpha_mt)
}
# Calculate the conditional means mu_mt (KMS 2015, eq.(2), MPS 2018, eq.(5)). First row for t=1, second for t=2 etc. First column for m=1,
# second column for m=2 etc.
mu_mt <- t(pars[1,] + t(Y[-nrow(Y),]%*%pars[2:(p + 1), , drop=FALSE]))
# Calculate/return conditional means
if(to_return == "regime_cmeans") {
return(mu_mt)
} else if(to_return == "total_cmeans") { # KMS 2015, eq.(4), MPS 2018, eq.(13)
return(rowSums(alpha_mt*mu_mt))
}
# Calculate "the second term" of the log-likelihood (KMS 2015, eq.(12)-(13), MPS 2018, eq.(14)-(15)) or quantile residuals
Y2 <- Y[2:nrow(Y), 1] # Only the first column and rows 2...T are needed
# GMAR type components
if(model == "GMAR" | model == "G-StMAR") {
invsqrt_sigmasM1 <- sigmas[1:M1]^(-1/2) # M1 = M for the GMAR model
smat <- diag(x=invsqrt_sigmasM1, nrow=length(invsqrt_sigmasM1), ncol=length(invsqrt_sigmasM1))
if(to_return == "qresiduals") { # Calculate quantile residuals; see Kalliovirta 2012 for the general formulas and framework
resM1 <- alpha_mt[,1:M1]*pnorm((Y2 - mu_mt[,1:M1])%*%smat)
lt_tmpM1 <- resM1 # We exploit the same names
} else {
lt_tmpM1 <- alpha_mt[,1:M1]*dnorm((Y2 - mu_mt[,1:M1])%*%smat)%*%smat
}
}
# StMAR type components
if(model == "StMAR" | model == "G-StMAR") {
sigmasM2 <- sigmas[(M1 + 1):M] # M1 = 0 and M2 = M for the StMAR model
matProd0 <- matProd[1:(n_obs - p), (M1 + 1):M] # The last row is not needed because sigma_t uses y_{t-1}
smat <- diag(x=sigmasM2, nrow=length(sigmasM2), ncol=length(sigmasM2))
dfmat1 <- diag(x=1/(dfs - 2 + p), nrow=length(dfs), ncol=length(dfs))
dfmat2 <- diag(x=dfs + p - 2, nrow=length(dfs), ncol=length(dfs))
sigma_mt <- crossprod(dfs - 2 + t(matProd0), dfmat1)%*%diag(x=sigmasM2, nrow=length(sigmasM2), ncol=length(sigmasM2))
if(to_return == "qresiduals") { # Calculate the integrals for the quantile residuals
resM2 <- matrix(ncol=M2, nrow=n_obs - p)
# Function for numerical integration of the pdf
my_integral <- function(i1, i2) { # Takes in the regime index i1 and the observation index i2 for the upper bound
f_mt <- function(y_t) { # The conditional density function to be integrated numerically
alpha_mt[i2, M1 + i1]*exp(lgamma(0.5*(1 + dfs[i1] + p)) - lgamma(0.5*(dfs[i1] + p)))/sqrt(sigma_mt[i2, i1]*base::pi*(dfs[i1] + p - 2))*
(1 + ((y_t - mu_mt[i2, M1 + i1])^2)/((dfs[i1] + p - 2)*sigma_mt[i2, i1]))^(-0.5*(1 + dfs[i1] + p))
}
tryCatch(integrate(f_mt, lower=-Inf, upper=Y2[i2])$value, # Integrate PDF numerically
error=function(e) {
warning("Couldn't analytically nor numerically integrate all quantile residuals:")
warning(e)
return(NA)
})
}
is_gsl <- requireNamespace("gsl", quietly = TRUE) # If 'gsl' available, calculate with hypergeometric function what can be calculated
for(i1 in 1:M2) { # Go through StMAR type regimes
if(is_gsl) {
whichDef <- which(abs(mu_mt[, M1 + i1] - Y2) < sqrt(sigma_mt[,i1]*(dfs[i1] + p - 2))) # Which ones can be calculated with hypergeometric function
whichNotDef <- (1:length(Y2))[-whichDef]
} else {
whichDef <- integer(0)
whichNotDef <- 1:length(Y2)
}
if(length(whichDef) > 0) { # Calculate the CDF values at y_t using hypergeometric function whenever it's defined
Y0 <- Y2[whichDef]
alpha_mt0 <- alpha_mt[whichDef, M1 + i1]
mu_mt0 <- mu_mt[whichDef, M1 + i1]
sigma_mt0 <- sigma_mt[whichDef, i1]
a0 <- exp(lgamma(0.5*(1 + dfs[i1] + p)) - lgamma(0.5*(dfs[i1] + p)))/sqrt(sigma_mt0*base::pi*(dfs[i1] + p - 2))
resM2[whichDef, i1] <- alpha_mt0*(0.5 - a0*(mu_mt0 - Y0)*gsl::hyperg_2F1(0.5, 0.5*(1 + dfs[i1] + p), 1.5,
-((mu_mt0 - Y0)^2)/(sigma_mt0*(dfs[i1] + p - 2)),
give=FALSE, strict=TRUE))
}
# Calculate the CDF values at y_t that can't be calculated with the hypergeometric function (from the package 'gsl')
if(length(whichNotDef) > 0) {
for(i2 in whichNotDef) {
resM2[i2, i1] <- my_integral(i1, i2)
}
}
}
lt_tmpM2 <- resM2 # We exploit the same names
} else { # Calculate l_t in the log-likelihood function
lt_tmpM2 <- alpha_mt[,(M1 + 1):M]*t(exp(lgamma(0.5*(1 + dfs + p)) - lgamma(0.5*(dfs + p)))/sqrt(base::pi*(dfs + p - 2))/t(sqrt(sigma_mt)))*
t(t(1 + ((Y2 - mu_mt[,(M1 + 1):M])^2)/(sigma_mt%*%dfmat2))^(-0.5*(1 + dfs + p)))
}
}
if(model == "GMAR") {
lt_tmp <- as.matrix(lt_tmpM1)
} else if(model == "StMAR") {
lt_tmp <- as.matrix(lt_tmpM2)
} else { # model == "G-StMAR
lt_tmp <- as.matrix(cbind(lt_tmpM1, lt_tmpM2))
}
l_t <- rowSums(lt_tmp)
# Return quantile residuals (note that l_t is different if qresiduals are not to be returned)
if(to_return == "qresiduals") {
res <- l_t
# To prevent problems with numerical approximations
res[which(res >= 1)] <- 1 - 2e-16
res[which(res <= 0)] <- 2e-16
return(qnorm(res))
}
# Calculate/return conditional variances
if(to_return == "regime_cvars" | to_return == "total_cvars") {
if(model == "GMAR") {
sigma_mt <- matrix(rep(sigmas, n_obs - p), ncol=M, byrow=TRUE)
} else if(model == "StMAR") {
sigma_mt <- as.matrix(sigma_mt)
} else if(model == "G-StMAR") {
sigma_mt1 <- matrix(rep(sigmas[1:M1], n_obs - p), ncol=M1, byrow=TRUE)
sigma_mt <- cbind(sigma_mt1, sigma_mt)
colnames(sigma_mt) <- NULL
}
if(to_return == "regime_cvars") {
return(sigma_mt)
} else { # Calculate and return the total conditional variances (KMS 2015, eq.(5), MPS 2018, eq.(13))
return(rowSums(alpha_mt*sigma_mt) - rowSums(alpha_mt*(mu_mt - rowSums(alpha_mt*mu_mt))^2))
}
}
if(to_return == "terms") {
ret <- log(l_t)
} else if(to_return == "loglik_and_mw") {
ret <- list(loglik=l_0 + sum(log(l_t)), mw=alpha_mt)
} else {
ret <- l_0 + sum(log(l_t)) # KMS 2015, eq.(12)-(13), MPS 2018, eq.(14)-(15)
}
ret
}
mymw <- my_mw(TBFF, p=5, M=c(1, 2), params=mod53$params, model="G-StMAR")
mymw <- my_mw(TBFF, p=5, M=c(1, 2), params=mod53$params, model="G-StMAR", to_return = "mw")
mymw
par(mfrow=c(1, 1))
plot(TBFF)
rowSums(mymw)
plot(ts(c(rep(NA, times=5), mymw[,1]), start=c(1954, 7), frequency=12), type="l", col=cols[1], ylim=c(0, 1), lty=3, ylab=NA, xaxt="n", yaxt="n")
plot(TBFF)
par(new=TRUE)
plot(ts(c(rep(NA, times=5), mymw[,1]), start=c(1954, 7), frequency=12), type="l", col=cols[1], ylim=c(0, 1), lty=3, ylab=NA, xaxt="n", yaxt="n")
lines(ts(c(rep(NA, times=5), my_mw[,2]), start=c(1954, 7), frequency=12), col=cols[2], lty=3)
lines(ts(c(rep(NA, times=5), mymw[,2]), start=c(1954, 7), frequency=12), col=cols[2], lty=3)
lines(ts(c(rep(NA, times=5), mymw[,3]), start=c(1954, 7), frequency=12), col=cols[2], lty=3)
plot(TBFF)
par(new=TRUE)
plot(ts(c(rep(NA, times=5), mymw[,1]), start=c(1954, 7), frequency=12), type="l", col=cols[1], ylim=c(0, 1), lty=3, ylab=NA, xaxt="n", yaxt="n")
lines(ts(c(rep(NA, times=5), mymw[,2]), start=c(1954, 7), frequency=12), col=cols[2], lty=3)
lines(ts(c(rep(NA, times=5), mymw[,3]), start=c(1954, 7), frequency=12), col=cols[3], lty=3)
plot(ts(c(rep(NA, times=5), mymw[,1]), start=c(1954, 7), frequency=12), type="l", col=cols[1], ylim=c(0, 1), lty=3, ylab=NA, xaxt="n", yaxt="n")
plot(ts(c(rep(NA, times=5), mymw[,1]), start=c(1954, 7), frequency=12), type="l", col="red")
plot(ts(c(rep(NA, times=5), mymw[,1]), start=c(1954, 7), frequency=12), type="l", col="red", lty=2)
plot(ts(c(rep(NA, times=5), mod53$mixing_weights[,1]), start=c(1954, 7), frequency=12), type="l", col="blue", lty=3)
plot(ts(c(rep(NA, times=5), mymw[,1]), start=c(1954, 7), frequency=12), type="l", col="red", lty=2)
lines(ts(c(rep(NA, times=5), mod53$mixing_weights[,1]), start=c(1954, 7), frequency=12), type="l", col="blue", lty=3)
plot(TBFF)
par(new=T)
plot(ts(c(rep(NA, times=5), mymw[,1]), start=c(1954, 7), frequency=12), type="l", col="red", lty=2)
lines(ts(c(rep(NA, times=5), mod53$mixing_weights[,1]), start=c(1954, 7), frequency=12), type="l", col="blue", lty=3)
rm(mymw)
rm(my_mwmw)
rm(my_mw)
summary(mod53, digits=5)
summary(mod53r, digits=5)
summary(mod52, digits=5)
sqrt(1/0.8)
## Exercise 1
c2 <- c(1114.4, 591.73)
C2 <- matrix(c(1382.2, 1114.4, 1114.4, 1382.2), ncol=2)
(phi_yw <- solve(C2, c2)) # YW estimate for phi1, phi2
(sigma2 <- 1382.2 - sum(c2*phi_yw)) # YW estimate for sigma2
solve(C2)
c2
## Exercise 1
c2 <- c(1114.4, 591.73)
C2 <- matrix(c(1382.2, 1114.4, 1114.4, 1382.2), ncol=2)
(phi_yw <- solve(C2, c2)) # YW estimate for phi1, phi2
(sigma2 <- 1382.2 - sum(c2*phi_yw)) # YW estimate for sigma2
stder196 <- 1.96*sqrt(diag(sigma2*solve(C2)/100)) # 1.96*approximate std errors for phi_yw
cbind(phi_yw - stder196, phi_yw + stder196) # Approximate 95% confidence intervals
stder196 <- 1.96*sqrt(diag(sigma2*solve(C2)/100)) # 1.96*approximate std errors for phi_yw
cbind(phi_yw - stder196, phi_yw + stder196) # Approximate 95% confidence intervals
1-0.05
qnorm(1-0.05/2)
## Exercise 1
c2 <- c(1114.4, 591.73)
C2 <- matrix(c(1382.2, 1114.4, 1114.4, 1382.2), ncol=2)
(phi_yw <- solve(C2, c2)) # YW estimate for phi1, phi2
(sigma2 <- 1382.2 - sum(c2*phi_yw)) # YW estimate for sigma2
sigma2
sqrt(diag(sigma2*solve(C2)/100))
diag(sigma2*solve(C2)/100)
15+ 10 + 17+ 30
12 + 27 + 20
12 + 27 + 20 + 30
15 + 27 + 20
20 + 27 + 19 +5
19+20+21+30
16 + 27 + 20 + 15
15 + 15 + 20
17 + 15 + 20
17 + 27 + 18 + 27
10+27+18+10
15 + 27 + 20
14 + 27 + 20
17 + 27 + 20
17+15+10
16 + 15+ 15 + 25
17 + 27 + 20
gmars4[[3]]$IC
0.5*(-1 + sqrt(5))
c0 <- 6.06
r1 <- 0.687
c1 <- c0*r1
Gamma <- matrix(c(c0, c1, c1, c0), nrow=2)
Gamma
rm(c0)
rm(r1)
rm(r0)
rm(c1)
rm(Gamma
)
rm(C2)
rm(c2)
(-1 + sqrt(1 + 4*0.687^2))/(2*0.687)
(-1 - sqrt(1 + 4*0.687^2))/(2*0.687)
6.06*0.687
c2 <- 0.509*4.163 - 0.509^2*6.06
c2
c2 <- 0.509*4.163 + 0.509^2*6.06
c2
6.06 - 0.509*4.163 - 0.509^2*c2
rm(c2)
load("\\\\ad.helsinki.fi/home/s/saviviro/Desktop/GSTMARartikkeli/empexample_env")
mod53
setwd("~/uGMAR")
devtools::load_all()
devtools::load_all()
mod53
sum(mod53$mixing_weights[,1])
sum(mod53$mixing_weights[,1])/length(mod53$mixing_weights[,1])
length(mod53$mixing_weights[,1])
sum(mod53$mixing_weights[,2])/length(mod53$mixing_weights[,1])
sum(mod53$mixing_weights[,3])/length(mod53$mixing_weights[,1])
0.035+2*0.025
0.043+2*0.035
sum(mod53r$mixing_weights[,1])/length(mod53$mixing_weights[,1])
0.09489143/4.3
0.09489143/0.043
0.09973203/0.035
gmars4[[3]]$IC
mod53$mixing_weights
ts(mod53$mixing_weights[,2], start=c(1954, 12), frequency=12)
ts(round(mod53$mixing_weights[,2], 1), start=c(1954, 12), frequency=12)
20 + 35 + 15 + 30
10 + 10+ 7 +7 +7 +7 +7 +15 + 30
20 + 7 + 10 + 20
20 + 7 + 5 + 5 + 5 + 20
20 + 6 + 7 + 6+ 2
20 + 15 + 26
20 + 7 + 7 +6 +15
20 +6 +7 + 7+ 3 + 15 + 25
20 + 7 +7 + 15
20 + 7+ 7 + 7 + 7 + 7
55 + 12
20 + 7 +7 +4 + 7 + +15
20 + 2 + 7 + 7 + + 15 + 15
20 + 7 + 7 + 7 + 1+ 6 + 15 + 25
20 + 7 + 7 + 7 + 5 + + 7 + 10
17  + 7 + 5 + 6 + 15 + 15
15 + 29
17  + 7 + 5 + 6 + 15 + 15
15  + 5 + 7 + 12 + 10
20  + 7+ 7 + + 7 + 4 + 15
tmpsample <- simulateGSMAR(mod53, nsimu=1000)
plot(tmpsample$sample, type="l")
tmpsample <- simulateGSMAR(mod53, nsimu=1000)
plot(tmpsample$sample, type="l")
tmpsample <- simulateGSMAR(mod53, nsimu=1000)
plot(tmpsample$sample, type="l")
tmpsample <- simulateGSMAR(mod53, nsimu=1000)
plot(tmpsample$sample, type="l")
tmpsample <- simulateGSMAR(mod53, nsimu=1000, initvalues = c(100, 100, 100, 100, 100))
plot(tmpsample$sample, type="l")
plot(tmpsample$sample[200:1000], type="l")
tmpsample <- simulateGSMAR(mod53, nsimu=1000, initvalues = c(10000, 10000, 10000, 10000, 10000))
plot(tmpsample$sample, type="l")
plot(tmpsample$sample[400:1000], type="l")
tmpsample <- simulateGSMAR(mod53, nsimu=1000, initvalues = c(1e12, 1e12, 1e12, 1e12, 1e12))
plot(tmpsample$sample, type="l")
tmpsample <- simulateGSMAR(mod53, nsimu=1000, initvalues = c(1e12, 1e12, 1e12, 1e12, 1e12))
plot(tmpsample$sample, type="l")
tmpsample <- simulateGSMAR(mod53, nsimu=1000, initvalues = c(100000, 100000, 100000, 100000, 100000))
plot(tmpsample$sample, type="l")
tmpsample <- simulateGSMAR(mod53, nsimu=1000, initvalues = c(100000, 100000, 100000, 100000, 100000))
plot(tmpsample$sample, type="l")
tmpsample <- simulateGSMAR(mod53, nsimu=1000, initvalues = c(10000, 10000, 10000, 10000, 10000))
plot(tmpsample$sample, type="l")
tmpsample <- simulateGSMAR(mod53, nsimu=1000, initvalues = c(10000, 10000, 10000, 10000, 10000))
plot(tmpsample$sample, type="l")
tmpsample <- simulateGSMAR(mod53, nsimu=1000, initvalues = c(10000, 10000, 10000, 10000, 10000))
plot(tmpsample$sample, type="l")
gmar12 <- GSMAR(p=1, M=2, params=c(1, 0.8, 0.5, 0, 0.6, 0.5, 0.6), parametrization = "mean")
tmpsample <- simulateGSMAR(gmar12, nsimu=5)
tmpsample
tmpfore <- simulateGSMAR(gmar12, nsimu=1, initvalues=tmpsample$sample, ntimes=10000)
tmpfore
tmpfore$sample
hist(tmpfore$sample)
tmpfore$mixing_weights[, , 1]
tmpfore$sample
tmpfore$component
hist(tmpfore$component)
tmpfore <- simulateGSMAR(gmar12, nsimu=10, initvalues=tmpsample$sample, ntimes=10000)
?simulateGSMAR
hist(tmpfore$sample[10,])
tmpfore <- simulateGSMAR(gmar12, nsimu=100, initvalues=tmpsample$sample, ntimes=10000)
hist(tmpfore$sample[100,])
hist(tmpfore$sample[50,])
tmp <- rnorm(20)
acf(tmp)
acf(tmp + 100)
18 + 15 + 29
