install.packages("roxygen2")
install.packages("roxygen2")
pkgbuild::has_build_tools()
install.packages("devtools")
setwd("~/uGMAR")
devtools::test()
?suppressMessages
suppressMessages(1+1)
devtools::load_all()
params12 <- c(1.7, 0.85, 0.3, 4.12, 0.73, 1.98, 0.63)
gmar12 <- GSMAR(data=simudata, p=1, M=2, params=params12, model="GMAR")
iterate_more0 <- function(gsmar) suppressMessages(iterate_more(gsmar, calc_std_errors=FALSE, maxit=1))
rm(iterate_more0())
rm(iterate_more0
)
iterate_more(gmar12, calc_std_errors=FALSE, maxit=1)
devtools::test()
fitGSMAR(simudata, p=1, M=2, model="GMAR", ncalls=1, ncores=1, maxit=1, seeds=1, printRes=FALSE)
suppressMessages(fitGSMAR(simudata, p=1, M=2, model="GMAR", ncalls=1, ncores=1, maxit=1, seeds=1, printRes=FALSE))
suppressMessages(fitGSMAR(simudata, p=1, M=2, model="GMAR", ncalls=1, ncores=1, maxit=1, seeds=1, printRes=FALSE, ngen=1))
suppressMessages(fitGSMAR(simudata, p=1, M=2, model="GMAR", ncalls=1, ncores=1, maxit=1, seeds=1, printRes=FALSE, ngen=2))
devtools::test()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
devtools::test()
tmp <- random_regime(p=4, meanscale=1:2, sigmascale=3, forcestat=TRUE)
tmp
tmp <- regime_distance(1:3, 1:3)
tmp
tmp <- regime_distance(1:3, 2:4)
tmp
?smart_individual_int
?smartIndividual_int
devtools::test()
devtools::test()
devtools::test()
fit12 <- fitGSMAR(simudata, p=1, M=2, model="GMAR")
summary(fit12)
plot(fit12)
profile_logliks(fit12)
devtools::document()
86918.15 - 8645.07
86918.15 - 86456.07
86456.07*0.4
86456.07*0.6
gstmar42r <- GSMAR(p=4, M=c(1, 1), params=params42gsr, model="G-StMAR", restricted=TRUE)
setwd("~/uGMAR")
devtools::load_all()
gstmar42r <- GSMAR(p=4, M=c(1, 1), params=params42gsr, model="G-StMAR", restricted=TRUE)
params42gsr <- c(0.11, 0.03, 1.27, -0.39, 0.24, -0.17, 0.03, 1.01, 0.3, 2.03)
gstmar42r <- GSMAR(p=4, M=c(1, 1), params=params42gsr, model="G-StMAR", restricted=TRUE)
gstmar42r$data
gstmar42r <- add_data(data=T10Y1Y, gstmar42r)
gstmar42r$data
gstmar42r <- GSMAR(data=T10Y1Y, p=4, M=c(1, 1), params=params42gsr, model="G-StMAR", restricted=TRUE)
gstmar42r2 <- swap_parametrization(gstmar42r)
gstmar42r2$params
fit11 <- fitGSMAR(T10Y1Y, 1, 1, model="StMAR", ncalls=2, ncores=1, maxit=1, seeds=1:2, ngen=1)
fit11 <- suppressMessages(fitGSMAR(T10Y1Y, 1, 1, model="StMAR", ncalls=2, ncores=1, maxit=1, seeds=1:2, ngen=1))
fit11 <- suppressMessages(fitGSMAR(T10Y1Y, 1, 1, model="StMAR", ncalls=2, ncores=1, maxit=1, seeds=1:2, printRes=FALSE, ngen=1))
fit11$all_logliks
devtools::test()
devtools::test()
devtools::test()
devtools::document()
setwd("~/uGMAR")
devtools::document()
devtools::document()
setwd("~/uGMAR")
devtools::document()
setwd("~/Documents/uGMAR")
devtools::load_all()
params23 <- c(2.7, 0.8, -0.06, 0.3, 3.5, 0.8, -0.07, 2.6, 7.2, 0.3, -0.01, 0.1, 0.6, 0.25)
params <- params23
p <- 2
M <- 3
data <- simudata
model <- "GMAR"
restricted=FALSE
constraints=NULL
conditional=TRUE
parametrization <- "intercept"
boundaries=TRUE
checks=TRUE
to_return <- "loglik"
minval <- get_minval(data)
M_orig <- M
if(model == "G-StMAR") {
M1 <- M[1]
M2 <- M[2]
M <- sum(M)
} else if(model == "GMAR") {
M1 <- M
M2 <- 0
} else { # model == "StMAR
M1 <- 0
M2 <- M
}
# Reform parameters to the "standard form" and collect them
if(checks) checkConstraintMat(p=p, M=M_orig, restricted=restricted, constraints=constraints)
params <- removeAllConstraints(p=p, M=M_orig, params=params, model=model, restricted=restricted, constraints=constraints)
pars <- pick_pars(p=p, M=M_orig, params=params, model=model, restricted=FALSE, constraints=NULL)
alphas <- pick_alphas(p=p, M=M_orig, params=params, model=model, restricted=FALSE, constraints=NULL)
dfs <- pick_dfs(p=p, M=M_orig, params=params, model=model)
sigmas <- pars[p + 2,] # sigma^2
# Return minval if the parameter is outside the parameters space
if(boundaries) {
if(any(pars[p + 2,] <= 0)) {
return(minval)
} else if(M >= 2 & sum(alphas[-M]) >= 1) {
return(minval)
} else if(any(alphas <= 0)) {
return(minval)
} else if(!isStationary_int(p, M, params, restricted=FALSE)) {
return(minval)
}
if(model == "StMAR" | model == "G-StMAR") {
if(any(dfs <= 2 + 1e-8 | dfs > 1e+5)) return(minval)
}
}
if(checks) {
data <- checkAndCorrectData(data=data, p=p)
parameterChecks(p=p, M=M_orig, params=params, model=model, restricted=FALSE, constraints=NULL)
}
n_obs <- length(data)
# Unconditional regimewise means, mu_m (KMS 2015, s.250, and MDP 2018, eq.(4))
if(parametrization == "mean") {
mu <- pars[1,]
pars[1,] <- mu*(1 - colSums(pars[2:(p + 1), , drop=FALSE]))
} else {
mu <- pars[1, ]/(1 - colSums(pars[2:(p + 1), , drop=FALSE]))
}
# Observed data: y_(-p+1),...,y_0,y_1,...,y_(n_obs-p). First row denotes vector y_0, i:th row vector y_[i-1] and last row denotes the vector y_T.
Y <- vapply(1:p, function(i1) data[(p - i1 + 1):(n_obs - i1 + 1)], numeric(n_obs - p + 1))
# Calculate inverse Gamma_m (see the covariance matrix Gamma_p in MPS 2018, p.3 - we calculate this for all mixture components using
# the inverse formula in Galbraith and Galbraith 1974). Also, calculate the matrix products in multivariate normal and t-distribution
# densities.
matProd <- matrix(nrow=n_obs - p + 1, ncol=M)
invG <- array(dim=c(p, p, M))
if(p == 1) {
for(i1 in 1:M) {
invG[, , i1] <- (1 - pars[p + 1, i1]^2)/sigmas[i1]
matProd[, i1] <- (Y - mu[i1])*invG[, , i1]*(Y - mu[i1])
}
} else {
for(i1 in 1:M) {
ARcoefs <- pars[2:(p + 1), i1]
U <- diag(1, nrow=p, ncol=p)
V <- diag(ARcoefs[p], nrow=p, ncol=p)
for(i2 in 1:(p - 1)) {
U[(i2 + 1):p, i2] <- -ARcoefs[1:(p - i2)]
V[(i2 + 1):p, i2] <- rev(ARcoefs[i2:(p - 1)])
}
invG[, , i1] <- (crossprod(U, U) - crossprod(V, V))/sigmas[i1]
matProd[, i1] <- rowSums((Y - mu[i1]*rep(1, p))%*%invG[, , i1]*(Y - mu[i1]*rep(1, p)))
}
}
# Calculate the multivariate normal or student's t values (KMS 2015, eq.(7) and MPS 2018, Theorem 1) in log for each vector y_t and for each m=1,..,M.
# First row for initial values \bm{y}_0 (as denoted by KMS 2015) and i:th row for \bm{y}_(i-1). First column for component m=1 and j:th column for m=j.
logmv_values <- matrix(nrow=(n_obs - p + 1), ncol=M)
if(model == "GMAR" | model == "G-StMAR") { # Multinormals
for(i1 in 1:M1) {
detG <- 1/det(as.matrix(invG[, , i1]))
logmv_values[,i1] <- -0.5*p*log(2*base::pi) - 0.5*log(detG) - 0.5*matProd[,i1]
}
}
if(model == "StMAR" | model == "G-StMAR") { # Multistudents
for(i1 in (M1 + 1):M) {
detG <- 1/det(as.matrix(invG[, , i1]))
logC <- lgamma(0.5*(p + dfs[i1 - M1])) - 0.5*p*log(base::pi) - 0.5*p*log(dfs[i1 - M1] - 2) - lgamma(0.5*dfs[i1 - M1])
logmv_values[,i1] <- logC - 0.5*log(detG) - 0.5*(p + dfs[i1 - M1])*log(1 + matProd[,i1]/(dfs[i1 - M1] - 2))
}
}
# Calculate the mixing weights alpha_mt (KMS 2015, eq.(8) and MPS 2018, eq.(11)).
# First row for t=1, second for t=2, and i:th for t=i. First column for m=1, second for m=2 and j:th column for m=j.
if(to_return != "mw_tplus1") {
logmv_values0 <- logmv_values[1:(n_obs - p),] # The last row is not needed because alpha_mt uses vector Y_(t-1)
} else {
logmv_values0 <- logmv_values # The last row is needed for alpha_{m,t+1}
}
any(logmv_values0 < epsilon)
epsilon <- round(log(.Machine$double.xmin) + 10)
logmv_values0 < epsilon
any(logmv_values0 < epsilon)
parametrization <- "mean"
# Unconditional regimewise means, mu_m (KMS 2015, s.250, and MDP 2018, eq.(4))
if(parametrization == "mean") {
mu <- pars[1,]
pars[1,] <- mu*(1 - colSums(pars[2:(p + 1), , drop=FALSE]))
} else {
mu <- pars[1, ]/(1 - colSums(pars[2:(p + 1), , drop=FALSE]))
}
# Observed data: y_(-p+1),...,y_0,y_1,...,y_(n_obs-p). First row denotes vector y_0, i:th row vector y_[i-1] and last row denotes the vector y_T.
Y <- vapply(1:p, function(i1) data[(p - i1 + 1):(n_obs - i1 + 1)], numeric(n_obs - p + 1))
# Calculate inverse Gamma_m (see the covariance matrix Gamma_p in MPS 2018, p.3 - we calculate this for all mixture components using
# the inverse formula in Galbraith and Galbraith 1974). Also, calculate the matrix products in multivariate normal and t-distribution
# densities.
matProd <- matrix(nrow=n_obs - p + 1, ncol=M)
invG <- array(dim=c(p, p, M))
if(p == 1) {
for(i1 in 1:M) {
invG[, , i1] <- (1 - pars[p + 1, i1]^2)/sigmas[i1]
matProd[, i1] <- (Y - mu[i1])*invG[, , i1]*(Y - mu[i1])
}
} else {
for(i1 in 1:M) {
ARcoefs <- pars[2:(p + 1), i1]
U <- diag(1, nrow=p, ncol=p)
V <- diag(ARcoefs[p], nrow=p, ncol=p)
for(i2 in 1:(p - 1)) {
U[(i2 + 1):p, i2] <- -ARcoefs[1:(p - i2)]
V[(i2 + 1):p, i2] <- rev(ARcoefs[i2:(p - 1)])
}
invG[, , i1] <- (crossprod(U, U) - crossprod(V, V))/sigmas[i1]
matProd[, i1] <- rowSums((Y - mu[i1]*rep(1, p))%*%invG[, , i1]*(Y - mu[i1]*rep(1, p)))
}
}
# Calculate the multivariate normal or student's t values (KMS 2015, eq.(7) and MPS 2018, Theorem 1) in log for each vector y_t and for each m=1,..,M.
# First row for initial values \bm{y}_0 (as denoted by KMS 2015) and i:th row for \bm{y}_(i-1). First column for component m=1 and j:th column for m=j.
logmv_values <- matrix(nrow=(n_obs - p + 1), ncol=M)
if(model == "GMAR" | model == "G-StMAR") { # Multinormals
for(i1 in 1:M1) {
detG <- 1/det(as.matrix(invG[, , i1]))
logmv_values[,i1] <- -0.5*p*log(2*base::pi) - 0.5*log(detG) - 0.5*matProd[,i1]
}
}
if(model == "StMAR" | model == "G-StMAR") { # Multistudents
for(i1 in (M1 + 1):M) {
detG <- 1/det(as.matrix(invG[, , i1]))
logC <- lgamma(0.5*(p + dfs[i1 - M1])) - 0.5*p*log(base::pi) - 0.5*p*log(dfs[i1 - M1] - 2) - lgamma(0.5*dfs[i1 - M1])
logmv_values[,i1] <- logC - 0.5*log(detG) - 0.5*(p + dfs[i1 - M1])*log(1 + matProd[,i1]/(dfs[i1 - M1] - 2))
}
}
# Calculate the mixing weights alpha_mt (KMS 2015, eq.(8) and MPS 2018, eq.(11)).
# First row for t=1, second for t=2, and i:th for t=i. First column for m=1, second for m=2 and j:th column for m=j.
if(to_return != "mw_tplus1") {
logmv_values0 <- logmv_values[1:(n_obs - p),] # The last row is not needed because alpha_mt uses vector Y_(t-1)
} else {
logmv_values0 <- logmv_values # The last row is needed for alpha_{m,t+1}
}
if(!is.matrix(logmv_values0)) logmv_values0 <- as.matrix(logmv_values0)
l_0 <- 0 # "The first term" of the exact log-likelihood function (KMS 2015, eq.(12) and MPS 2018, eq.(14))
any(logmv_values0 < epsilon)
logmv_values0 < epsilon
logmv_values0
devtools::load_all()
params11 <- c(2.1, 0.7, 1.1)
params11t <- c(0.9, 0.92, 1.01, 2.89)
params12 <- c(1.7, 0.85, 0.3, 4.12, 0.73, 1.98, 0.63)
params12t <- c(1.1, 0.9, 0.3, 4.5, 0.7, 3.2, 0.8, 5, 8) # StMAR
params22 <- c(1.2, 0.8, 0.05, 0.3, 3.5, 0.8, -0.1, 2.8, 0.8)
params22t <- c(1.4, 0.8, 0.05, 0.27, 3.5, 0.9, -0.18, 3.1, 0.7, 203, 3) # StMAR
params23 <- c(2.7, 0.8, -0.06, 0.3, 3.5, 0.8, -0.07, 2.6, 7.2, 0.3, -0.01, 0.1, 0.6, 0.25)
params12bound <- c(0.4, 0.4, 0.4, 0.6, 0.6, 0.6, 0.0)
params22bound <- c(1, 1, 0.1, 1, 2, 0.2, 0.2, 0.2, 0.7)
params12r <- c(2.18, 2.93, 0.81, 0.29, 1.9, 0.64)
params12tr <- c(0.8, 0.96, 0.9, 0.4, 5.8, 0.9, 4, 272) # StMAR
params23r <- c(1.7, 1.9, 2.1, 0.8, -0.05, 0.3, 0.7, 4.5, 0.7, 0.2)
params23tr <-  c(1.9, 1.6, 2.1, 0.8, -0.02, 0.4, 0.1, 3.9, 0.6, 0.3, 15, 13, 10) # StMAR
params12rbound <- c(1, 2, 0.2, -0.1, 0.6)
params13rbound <- c(0.1, 0.2, 0.3, 0.5, 0.1, 0.2, 0.3, 0.5, 0.5)
R1 <- matrix(c(1, 0, 0, 0, 0, 1), ncol=2)
R2 <- diag(1, ncol=3, nrow=3)
R3 <- matrix(c(0.5, 0.5), ncol=1)
R4 <- diag(1, ncol=2, nrow=2)
params32c <- c(1, 0.1, -0.1, 1, 2, 0.2, -0.2, 2, 0.6, 11, 12) # R1, R1, StMAR
params33c <- c(1, 0.1, 0.1, 0.1, 1, 2, 0.2, 0.2, 0.2, 2, 3, 0.3, -0.3, 3, 0.5, 0.4) # R2, R2, R1
params21c <- c(1, 0.9, 1, 3) # R3, StMAR
params22c <- c(1, 0.1, -0.1, 1, 2, 0.2, 2, 0.8, 11, 12) # R4, R3, StMAR
params22c_2 <- c(1.2, 0.8, 0.05, 0.3, 3.5, 0.8, -0.1, 2.8, 0.8) # R4, R4 (should be same as non-constrained)
params21cr <- c(1, 1, 1) # R3 bound
params22cr <- c(1, 2, 0.8, 1, 2, 0.7, 11, 12) # R3, StMAR
params32cr <- c(1, 2, 0.3, -0.3, 1, 2, 0.6) # R1
params23cr <- c(1.7, 1.9, 2.1, 0.8, -0.05, 0.3, 0.7, 4.5, 0.7, 0.2) # R4 (should be same as non-constrained)
params12gs <- c(4.13, 0.73, 1.98, 1.7, 0.85, 0.3, 0.37, 9) # M1=1, M2=1
params23gs <- c(1, 0.1, 0.1, 1, 1.2, 0.2, 0.2, 1.2, 1.3, 0.3, -0.3, 1.3, 0.3, 0.4, 11, 12) # M1=1, M2=2
params13gsr <- c(4.8, 3.31, 3.74, 0.69, 2, 0.19, 0.41, 0.34, 0.3, 9) # M1=2, M2=1
params12gs2 <- c(1.5, 0.8, 1.5, 2.9, 0.8, 1.1, 0.6, 3) # M1=1, M2=1
params13gsr2 <- c(1.3, 1, 1.4, 0.8, 0.4, 2, 0.2, 0.25, 0.15, 11) # M1=2, M2=1
params32gsc <- c(1, 0.1, 0.1, 1, 2, 0.2, 0.2, 0.2, 2, 0.6, 10) # M1=1, M2=1, R1, R2
params22gsrc <- c(1, 2, 0.5, 1, 2, 0.5, 10) # M1=1, M2=1, R3
loglikelihood_int(-10*simudata, 2, 2, params22t, model="StMAR")
loglikelihood_int(-10*simudata, 2, 2, params22t, model="StMAR", parametrization="mean")
loglikelihood_int(simudata, 2, 3, params23, model="GMAR", parametrization="mean")
loglikelihood_int(-0.7*simudata, 1, c(1, 1), params12gs, model="G-StMAR", conditional=FALSE)
loglikelihood_int(simudata, 2, c(1, 2), params23gs, model="G-StMAR", parametrization="mean")
loglikelihood_int(-0.3*simudata, 2, c(1, 2), params23gs, model="G-StMAR", parametrization="mean")
loglikelihood_int(-0.3*simudata, 2, c(1, 2), params23gs, model="G-StMAR")
loglikelihood_int(3*simudata, 2, 3, params23tr, model="StMAR", restricted=TRUE, parametrization="mean")
loglikelihood_int(simudata, 1, c(2, 1), params13gsr2, model="G-StMAR", restricted=TRUE)
loglikelihood_int(-0.6*simudata, 1, c(2, 1), params13gsr2, model="G-StMAR", restricted=TRUE)
loglikelihood_int(7*simudata, 2, 2, params22cr, model="StMAR", restricted=TRUE, constraints=R3)
loglikelihood_int(0.5*simudata, 3, 2, params32cr, restricted=TRUE, constraints=R1, conditional=FALSE)
loglikelihood_int(0.7*simudata, 3, 2, params32cr, restricted=TRUE, constraints=R1, conditional=FALSE)
loglikelihood_int(3*simudata, 3, 2, params32c, model="StMAR", constraints=list(R1, R1), conditional=FALSE)
devtools::test()
devtools::load_all()
devtools::document()
devtools::test()
devtools::load_all()
devtools::test()
loglikelihood_int(simudata, 1, 2, params12t, model="StMAR")
loglikelihood_int(5*simudata[10:50], 1, 2, params12, conditional=FALSE, model="GMAR")
data <- 5*simudata[10:50]
p <- 1
M <- 2
params <- params12
conditional=FALSE
epsilon <- round(log(.Machine$double.xmin) + 10)
model <- match.arg(model)
parametrization <- match.arg(parametrization)
to_return <- match.arg(to_return)
M_orig <- M
if(model == "G-StMAR") {
M1 <- M[1]
M2 <- M[2]
M <- sum(M)
} else if(model == "GMAR") {
M1 <- M
M2 <- 0
} else { # model == "StMAR
M1 <- 0
M2 <- M
}
# Reform parameters to the "standard form" and collect them
if(checks) checkConstraintMat(p=p, M=M_orig, restricted=restricted, constraints=constraints)
params <- removeAllConstraints(p=p, M=M_orig, params=params, model=model, restricted=restricted, constraints=constraints)
pars <- pick_pars(p=p, M=M_orig, params=params, model=model, restricted=FALSE, constraints=NULL)
alphas <- pick_alphas(p=p, M=M_orig, params=params, model=model, restricted=FALSE, constraints=NULL)
dfs <- pick_dfs(p=p, M=M_orig, params=params, model=model)
sigmas <- pars[p + 2,] # sigma^2
# Return minval if the parameter is outside the parameters space
if(boundaries) {
if(any(pars[p + 2,] <= 0)) {
return(minval)
} else if(M >= 2 & sum(alphas[-M]) >= 1) {
return(minval)
} else if(any(alphas <= 0)) {
return(minval)
} else if(!isStationary_int(p, M, params, restricted=FALSE)) {
return(minval)
}
if(model == "StMAR" | model == "G-StMAR") {
if(any(dfs <= 2 + 1e-8 | dfs > 1e+5)) return(minval)
}
}
if(checks) {
data <- checkAndCorrectData(data=data, p=p)
parameterChecks(p=p, M=M_orig, params=params, model=model, restricted=FALSE, constraints=NULL)
}
n_obs <- length(data)
# Unconditional regimewise means, mu_m (KMS 2015, s.250, and MDP 2018, eq.(4))
if(parametrization == "mean") {
mu <- pars[1,]
pars[1,] <- mu*(1 - colSums(pars[2:(p + 1), , drop=FALSE]))
} else {
mu <- pars[1, ]/(1 - colSums(pars[2:(p + 1), , drop=FALSE]))
}
# Observed data: y_(-p+1),...,y_0,y_1,...,y_(n_obs-p). First row denotes vector y_0, i:th row vector y_[i-1] and last row denotes the vector y_T.
Y <- vapply(1:p, function(i1) data[(p - i1 + 1):(n_obs - i1 + 1)], numeric(n_obs - p + 1))
# Calculate inverse Gamma_m (see the covariance matrix Gamma_p in MPS 2018, p.3 - we calculate this for all mixture components using
# the inverse formula in Galbraith and Galbraith 1974). Also, calculate the matrix products in multivariate normal and t-distribution
# densities.
matProd <- matrix(nrow=n_obs - p + 1, ncol=M)
invG <- array(dim=c(p, p, M))
if(p == 1) {
for(i1 in 1:M) {
invG[, , i1] <- (1 - pars[p + 1, i1]^2)/sigmas[i1]
matProd[, i1] <- (Y - mu[i1])*invG[, , i1]*(Y - mu[i1])
}
} else {
for(i1 in 1:M) {
ARcoefs <- pars[2:(p + 1), i1]
U <- diag(1, nrow=p, ncol=p)
V <- diag(ARcoefs[p], nrow=p, ncol=p)
for(i2 in 1:(p - 1)) {
U[(i2 + 1):p, i2] <- -ARcoefs[1:(p - i2)]
V[(i2 + 1):p, i2] <- rev(ARcoefs[i2:(p - 1)])
}
invG[, , i1] <- (crossprod(U, U) - crossprod(V, V))/sigmas[i1]
matProd[, i1] <- rowSums((Y - mu[i1]*rep(1, p))%*%invG[, , i1]*(Y - mu[i1]*rep(1, p)))
}
}
# Calculate the multivariate normal or student's t values (KMS 2015, eq.(7) and MPS 2018, Theorem 1) in log for each vector y_t and for each m=1,..,M.
# First row for initial values \bm{y}_0 (as denoted by KMS 2015) and i:th row for \bm{y}_(i-1). First column for component m=1 and j:th column for m=j.
logmv_values <- matrix(nrow=(n_obs - p + 1), ncol=M)
if(model == "GMAR" | model == "G-StMAR") { # Multinormals
for(i1 in 1:M1) {
detG <- 1/det(as.matrix(invG[, , i1]))
logmv_values[,i1] <- -0.5*p*log(2*base::pi) - 0.5*log(detG) - 0.5*matProd[,i1]
}
}
if(model == "StMAR" | model == "G-StMAR") { # Multistudents
for(i1 in (M1 + 1):M) {
detG <- 1/det(as.matrix(invG[, , i1]))
logC <- lgamma(0.5*(p + dfs[i1 - M1])) - 0.5*p*log(base::pi) - 0.5*p*log(dfs[i1 - M1] - 2) - lgamma(0.5*dfs[i1 - M1])
logmv_values[,i1] <- logC - 0.5*log(detG) - 0.5*(p + dfs[i1 - M1])*log(1 + matProd[,i1]/(dfs[i1 - M1] - 2))
}
}
# Calculate the mixing weights alpha_mt (KMS 2015, eq.(8) and MPS 2018, eq.(11)).
# First row for t=1, second for t=2, and i:th for t=i. First column for m=1, second for m=2 and j:th column for m=j.
if(to_return != "mw_tplus1") {
logmv_values0 <- logmv_values[1:(n_obs - p),] # The last row is not needed because alpha_mt uses vector Y_(t-1)
} else {
logmv_values0 <- logmv_values # The last row is needed for alpha_{m,t+1}
}
if(!is.matrix(logmv_values0)) logmv_values0 <- as.matrix(logmv_values0)
l_0 <- 0 # "The first term" of the exact log-likelihood function (KMS 2015, eq.(12) and MPS 2018, eq.(14))
any(logmv_values0 < epsilon)
l_0 <- 0 # "The first term" of the exact log-likelihood function (KMS 2015, eq.(12) and MPS 2018, eq.(14))
if(M == 1) { # No need to do calculations is only one regime.
alpha_mt <- as.matrix(rep(1, nrow(logmv_values0)))
if(conditional == FALSE && (to_return == "loglik" | to_return == "loglik_and_mw")) {
l_0 <- logmv_values[1]
}
} else if(any(logmv_values0 < epsilon)) { # Close to zero values handled with package Brobdingnag if needed.
numerators <- lapply(1:M, function(i1) alphas[i1]*exp(Brobdingnag::as.brob(logmv_values0[,i1]))) # alphas[i1]*Brobdingnag::as.brob(exp(1))^logmv_values0[,i1]
denominator <- Reduce("+", numerators) # For all t=0,...,T
alpha_mt <- vapply(1:M, function(i1) as.numeric(numerators[[i1]]/denominator), numeric(nrow(logmv_values0)))
if(conditional == FALSE && (to_return == "loglik" | to_return == "loglik_and_mw")) {
l_0 <- log(Reduce("+", lapply(1:M, function(i1) numerators[[i1]][1])))
}
} else {
mv_values0 <- exp(logmv_values0)
denominator <- as.vector(mv_values0%*%alphas)
alpha_mt <- (mv_values0/denominator)%*%diag(alphas)
if(conditional == FALSE && (to_return == "loglik" | to_return == "loglik_and_mw")) {
l_0 <- log(sum(alphas*mv_values0[1,]))
}
}
alpha_mt0
alpha_mt0 <- alpha_mt
l_00 <- l_0
alpha_mt_and_l_0 <- get_alpha_mt(M=M, log_mvnvalues=logmv_values0, alphas=alphas,
epsilon=epsilon, conditional=conditional, to_return=to_return,
also_l_0=TRUE)
alpha_mt <- alpha_mt_and_l_0$alpha_mt
l_0 <- alpha_mt_and_l_0$l_0 # The first term in the exact log-likelihood function (=0 for conditional)
l_0
l_00
alpha_mt - alpha_mt0
l_0
l_00
log(Reduce("+", lapply(1:M, function(i1) numerators[[i1]][1])))
log(sum(alphas*mv_values0[1,]))
numerators
alpha_mt[1,]
log_mvnvalues=logmv_values0
small_logmvns <- log_mvnvalues < epsilon
# If too small or large non-log-density values are present (i.e., that would yield -Inf or Inf),
# we replace them with ones that are not too small or large but imply the same mixing weights
# up to negligible numerical tolerance.
which_change <- rowSums(small_logmvns) > 0 # Which rows contain too small  values
to_change <- log_mvnvalues[which_change, , drop=FALSE]
largest_vals <- do.call(pmax, split(to_change, f=rep(1:ncol(to_change), each=nrow(to_change)))) # The largest values of those rows
diff_to_largest <- to_change - largest_vals # Differences to the largest value of the row
# For each element in each row, check the (negative) distance from the largest value of the row. If the difference
# is smaller than epsilon, replace the with epsilon. The results are then the new log_mvn values.
diff_to_largest[diff_to_largest < epsilon] <- epsilon
# Replace the old log_mvnvalues with the new ones
log_mvnvalues[which_change,] <- diff_to_largest
log_mvnvalues
logmv_values0
log_mvnvalues_orig < epsilon
log_mvnvalues <- logmv_values0
small_logmvns <- log_mvnvalues < epsilon
if(any(small_logmvns)) {
# If too small or large non-log-density values are present (i.e., that would yield -Inf or Inf),
# we replace them with ones that are not too small or large but imply the same mixing weights
# up to negligible numerical tolerance.
which_change <- rowSums(small_logmvns) > 0 # Which rows contain too small  values
to_change <- log_mvnvalues[which_change, , drop=FALSE]
largest_vals <- do.call(pmax, split(to_change, f=rep(1:ncol(to_change), each=nrow(to_change)))) # The largest values of those rows
diff_to_largest <- to_change - largest_vals # Differences to the largest value of the row
# For each element in each row, check the (negative) distance from the largest value of the row. If the difference
# is smaller than epsilon, replace the with epsilon. The results are then the new log_mvn values.
diff_to_largest[diff_to_largest < epsilon] <- epsilon
# Replace the old log_mvnvalues with the new ones
log_mvnvalues_orig <- log_mvnvalues
log_mvnvalues[which_change,] <- diff_to_largest
}
mvnvalues <- exp(log_mvnvalues)
denominator <- as.vector(mvnvalues%*%alphas)
alpha_mt <- (mvnvalues/denominator)%*%diag(alphas)
log_mvnvalues_orig
log_mvnvalues_orig[1,] < epsilon
alphas[i1]*exp(Brobdingnag::as.brob(logmv_values0[,i1]))
exp(Brobdingnag::as.brob(logmv_values0[1,]))
alphas[i1]*exp(Brobdingnag::as.brob(logmv_values0[1,]))
sum(alphas[i1]*exp(Brobdingnag::as.brob(logmv_values0[1,])))
log(Reduce("+", lapply(1:M, function(i1) numerators[[i1]][1])))
devtools::load_all()
alpha_mt_and_l_0 <- get_alpha_mt(M=M, log_mvnvalues=logmv_values0, alphas=alphas,
epsilon=epsilon, conditional=conditional, to_return=to_return,
also_l_0=TRUE)
alpha_mt <- alpha_mt_and_l_0$alpha_mt
l_0 <- alpha_mt_and_l_0$l_0 # The first term in the exact log-likelihood function (=0 for conditional)
l_0
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
devtools::load_all()
devtools::test()
log(Reduce("+", lapply(1:M, function(i1) alphas[i1]*exp(Brobdingnag::as.brob(log_mvnvalues_orig[1, i1])))))
l_00
devtools::load_all()
devtools::test()
