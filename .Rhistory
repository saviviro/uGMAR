}
}
} else { # restricted == TRUE
}
tmp <- list(a=expression(beta))
get("m")
plot(x=vals, y=logliks, type="l", main=substitute(Delta[(foo)], list(foo=c(m,p))))#expression(paste(beta [paste(eval(get("m")), ",0")])))#, "(", m, ",0)")))
abline(v=pars[i1], col="red")
}
for(i1 in seq_len(npars)) { # Go though the parameters
pars <- params
range <- abs(scale*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=100) # Loglik to be evaluated at these values of the parameter considered
logliks <- vapply(vals, function(val) {
new_pars <- pars
new_pars[i1] <- val # Change the single parameter value
loglikelihood_int(data=gsmar$data, p=p, M=M, params=new_pars, model=gsmar$model$model, restricted=gsmar$model$restricted,
constraints=constraints, conditional=gsmar$model$conditional, boundaries=TRUE, checks=FALSE, minval=NA)
}, numeric(1))
# In order to get the labels right, we first determine which parameter is in question.
# With constraints AR parameters are not phi-parameters! So different label.
if(restricted == FALSE) {
# phi and sigma^2 parameters
if(i1 <= max(cum_q)) {
m <- sum(i1 > cum_q) # Which regime are we considering
if(i1 == cum_q[m] + 1) { # phi_{m,0}
1
}
}
} else { # restricted == TRUE
}
tmp <- list(a=expression(beta))
get("m")
plot(x=vals, y=logliks, type="l", main=substitute(Delta[foo], list(foo=c(m,p))))#expression(paste(beta [paste(eval(get("m")), ",0")])))#, "(", m, ",0)")))
abline(v=pars[i1], col="red")
}
paste0(m, ",", p)
for(i1 in seq_len(npars)) { # Go though the parameters
pars <- params
range <- abs(scale*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=100) # Loglik to be evaluated at these values of the parameter considered
logliks <- vapply(vals, function(val) {
new_pars <- pars
new_pars[i1] <- val # Change the single parameter value
loglikelihood_int(data=gsmar$data, p=p, M=M, params=new_pars, model=gsmar$model$model, restricted=gsmar$model$restricted,
constraints=constraints, conditional=gsmar$model$conditional, boundaries=TRUE, checks=FALSE, minval=NA)
}, numeric(1))
# In order to get the labels right, we first determine which parameter is in question.
# With constraints AR parameters are not phi-parameters! So different label.
if(restricted == FALSE) {
# phi and sigma^2 parameters
if(i1 <= max(cum_q)) {
m <- sum(i1 > cum_q) # Which regime are we considering
if(i1 == cum_q[m] + 1) { # phi_{m,0}
1
}
}
} else { # restricted == TRUE
}
tmp <- list(a=expression(beta))
get("m")
plot(x=vals, y=logliks, type="l", main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))#expression(paste(beta [paste(eval(get("m")), ",0")])))#, "(", m, ",0)")))
abline(v=pars[i1], col="red")
}
main <- quote(substitute(Delta[foo], list(foo=paste0(m, ",", p)))
plot(x=vals, y=logliks, type="l", main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
abline(v=pars[i1], col="red")
}
}
main <- quote(substitute(Delta[foo], list(foo=paste0(m, ",", p))))
main
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
main <- expression(substitute(Delta[foo], list(foo=paste0(m, ",", p))))
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
substitute(Delta[foo], list(foo=paste0(m, ",", p)))
main <- (substitute(Delta[foo], list(foo=paste0(m, ",", p))))
main
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
main <- substitute(Delta[foo], list(foo=paste0(m, ",", p)))
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
typeof(substitute(Delta[foo], list(foo=paste0(m, ",", p))))
is.expression(substitute(Delta[foo], list(foo=paste0(m, ",", p))))
is.call(substitute(Delta[foo], list(foo=paste0(m, ",", p))))
i1=1
pars <- params
range <- abs(scale*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=100) # Loglik to be evaluated at these values of the parameter considered
logliks <- vapply(vals, function(val) {
new_pars <- pars
new_pars[i1] <- val # Change the single parameter value
loglikelihood_int(data=gsmar$data, p=p, M=M, params=new_pars, model=gsmar$model$model, restricted=gsmar$model$restricted,
constraints=constraints, conditional=gsmar$model$conditional, boundaries=TRUE, checks=FALSE, minval=NA)
}, numeric(1))
m <- sum(i1 > cum_q) # Which regime are we considering
m
cum_q(m)
cum_q[m]
par(mar=c(2.1, 2.1, 1.1, 1), mfrow=c(nrows, ncols))
i1 - cum_q
i1 - cum_q[m]
i1 - cum_q[m] - 1
cum_q[m + 1]
cum_q
par(mar=c(2.1, 2.1, 1.1, 1), mfrow=c(nrows, ncols))
for(i1 in seq_len(npars)) { # Go though the parameters
pars <- params
range <- abs(scale*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=100) # Loglik to be evaluated at these values of the parameter considered
logliks <- vapply(vals, function(val) {
new_pars <- pars
new_pars[i1] <- val # Change the single parameter value
loglikelihood_int(data=gsmar$data, p=p, M=M, params=new_pars, model=gsmar$model$model, restricted=gsmar$model$restricted,
constraints=constraints, conditional=gsmar$model$conditional, boundaries=TRUE, checks=FALSE, minval=NA)
}, numeric(1))
# In order to get the labels right, we first determine which parameter is in question.
# With constraints AR parameters are not phi-parameters! So different label.
if(restricted == FALSE) {
# phi and sigma^2 parameters
if(i1 <= max(cum_q)) {
m <- sum(i1 > cum_q) # Which regime are we considering
if(i1 == cum_q[m + 1]) { # sigma^2
main <- substitute(sigma[foo], list(foo=paste0(m, ",", p))) # make square later
} else { # phi_{m,0},...,phi_{m,p}
p0 <- i1 - cum_q[m] - 1 # p0 = 0,..,p
main <- substitute(phi[foo], list(foo=paste0(m, ",", p)))
# if(i1 == cum_q[m] + 1) { # phi_{m,0}
#   p0 <- 0
# } else {}
# main <- substitute(Delta[foo], list(foo=paste0(m, ",", p)))
}
}
} else { # restricted == TRUE
}
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
abline(v=pars[i1], col="red")
}
i1 - cum_q[m] - 1
i1 <- 1
m <- 1
cum_q[m]
cum_q[m] - 1
par(mar=c(2.1, 2.1, 1.1, 1), mfrow=c(nrows, ncols))
# In order to get the labels right, we first determine which indeces in params
# correspond to which parameters: different procedure for restricted model.
if(restricted == FALSE) {
if(is.null(constraints)) {
all_q <- vapply(1:length(constraints), function(m) ncol(constraints[m]), numeric(1))
} else {
all_q <- rep(p, sum(M)) # Consider non-constrained models as special cases of constrainted models
}
cum_q <- c(0, cumsum(all_q + 2)) # Indeces in parameter vector after which the regime changes (before alphas)
} else { # restricted == TRUE
q <- ifelse(is.null(constraints), p, ncol(constraints)) # Constraints is a singe matrix
}
for(i1 in seq_len(npars)) { # Go though the parameters
pars <- params
range <- abs(scale*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=100) # Loglik to be evaluated at these values of the parameter considered
logliks <- vapply(vals, function(val) {
new_pars <- pars
new_pars[i1] <- val # Change the single parameter value
loglikelihood_int(data=gsmar$data, p=p, M=M, params=new_pars, model=gsmar$model$model, restricted=gsmar$model$restricted,
constraints=constraints, conditional=gsmar$model$conditional, boundaries=TRUE, checks=FALSE, minval=NA)
}, numeric(1))
# In order to get the labels right, we first determine which parameter is in question.
# With constraints AR parameters are not phi-parameters! So different label.
if(restricted == FALSE) {
# phi and sigma^2 parameters
if(i1 <= max(cum_q)) {
m <- sum(i1 > cum_q) # Which regime are we considering
if(i1 == cum_q[m + 1]) { # sigma^2
main <- substitute(sigma[foo], list(foo=paste0(m, ",", p))) # make square later
} else { # phi_{m,0},...,phi_{m,p}
if(i1 == cum_q[m] + 1) { # phi_{m,0}
p0 <- 0
} else {
p0 <- i1 - cum_q[m] - 1 # p0 = 1,...,p, minus 1 from phi_0
}
main <- substitute(phi[foo], list(foo=paste0(m, ",", p0)))
}
}
} else { # restricted == TRUE
}
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
abline(v=pars[i1], col="red")
}
precission=200
for(i1 in seq_len(npars)) { # Go though the parameters
pars <- params
range <- abs(scale*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=precission) # Loglik to be evaluated at these values of the parameter considered
logliks <- vapply(vals, function(val) {
new_pars <- pars
new_pars[i1] <- val # Change the single parameter value
loglikelihood_int(data=gsmar$data, p=p, M=M, params=new_pars, model=gsmar$model$model, restricted=gsmar$model$restricted,
constraints=constraints, conditional=gsmar$model$conditional, boundaries=TRUE, checks=FALSE, minval=NA)
}, numeric(1))
# In order to get the labels right, we first determine which parameter is in question.
# With constraints AR parameters are not phi-parameters! So different label.
if(restricted == FALSE) {
# phi and sigma^2 parameters
if(i1 <= max(cum_q)) {
m <- sum(i1 > cum_q) # Which regime are we considering
if(i1 == cum_q[m + 1]) { # sigma^2
main <- substitute(sigma[foo], list(foo=paste0(m, ",", p))) # make square later
} else { # phi_{m,0},...,phi_{m,p}
if(i1 == cum_q[m] + 1) { # phi_{m,0}
p0 <- 0
} else {
p0 <- i1 - cum_q[m] - 1 # p0 = 1,...,p, minus 1 from phi_0
}
main <- substitute(phi[foo], list(foo=paste0(m, ",", p0)))
}
}
} else { # restricted == TRUE
}
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
abline(v=pars[i1], col="red")
}
sum(all_q)
sum(all_q)
for(i1 in seq_len(npars)) { # Go though the parameters
pars <- params
range <- abs(scale*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=precission) # Loglik to be evaluated at these values of the parameter considered
logliks <- vapply(vals, function(val) {
new_pars <- pars
new_pars[i1] <- val # Change the single parameter value
loglikelihood_int(data=gsmar$data, p=p, M=M_orig, params=new_pars, model=gsmar$model$model, restricted=gsmar$model$restricted,
constraints=constraints, conditional=gsmar$model$conditional, boundaries=TRUE, checks=FALSE, minval=NA)
}, numeric(1))
# In order to get the labels right, we first determine which parameter is in question.
# With constraints AR parameters are not phi-parameters! So different label.
if(restricted == FALSE) {
# phi and sigma^2 parameters
if(i1 <= max(cum_q)) {
m <- sum(i1 > cum_q) # Which regime are we considering
if(i1 == cum_q[m + 1]) { # sigma^2
main <- substitute(sigma[foo]^2, list(foo=paste0(m, ",", p))) # make square later
} else if(i1 <= sum(all_q) + M*2) { # phi_{m,0},...,phi_{m,p}
if(i1 == cum_q[m] + 1) { # phi_{m,0}
p0 <- 0
} else {
p0 <- i1 - cum_q[m] - 1 # p0 = 1,...,p, minus 1 from phi_0
}
main <- substitute(phi[foo], list(foo=paste0(m, ",", p0)))
} else { # alphas and degrees of freedom if any
}
}
} else { # restricted == TRUE
}
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
abline(v=pars[i1], col="red")
}
par(mar=c(2.1, 2.1, 1.1, 1.1), mfrow=c(nrows, ncols))
for(i1 in seq_len(npars)) { # Go though the parameters
pars <- params
range <- abs(scale*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=precission) # Loglik to be evaluated at these values of the parameter considered
logliks <- vapply(vals, function(val) {
new_pars <- pars
new_pars[i1] <- val # Change the single parameter value
loglikelihood_int(data=gsmar$data, p=p, M=M_orig, params=new_pars, model=gsmar$model$model, restricted=gsmar$model$restricted,
constraints=constraints, conditional=gsmar$model$conditional, boundaries=TRUE, checks=FALSE, minval=NA)
}, numeric(1))
# In order to get the labels right, we first determine which parameter is in question.
# With constraints AR parameters are not phi-parameters! So different label.
if(restricted == FALSE) {
# phi and sigma^2 parameters
if(i1 <= max(cum_q)) {
m <- sum(i1 > cum_q) # Which regime are we considering
if(i1 == cum_q[m + 1]) { # sigma^2
main <- substitute(sigma[foo]^2, list(foo=paste0(m, ",", p))) # make square later
} else if(i1 <= sum(all_q) + M*2) { # phi_{m,0},...,phi_{m,p}
if(i1 == cum_q[m] + 1) { # phi_{m,0}
p0 <- 0
} else {
p0 <- i1 - cum_q[m] - 1 # p0 = 1,...,p, minus 1 from phi_0
}
main <- substitute(phi[foo], list(foo=paste0(m, ",", p0)))
} else { # alphas and degrees of freedom if any
}
}
} else { # restricted == TRUE
}
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
abline(v=pars[i1], col="red")
}
M_orig <- gsmar$model$M
M <- sum(M_orig)
for(i1 in seq_len(npars)) { # Go though the parameters
pars <- params
range <- abs(scale*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=precission) # Loglik to be evaluated at these values of the parameter considered
logliks <- vapply(vals, function(val) {
new_pars <- pars
new_pars[i1] <- val # Change the single parameter value
loglikelihood_int(data=gsmar$data, p=p, M=M_orig, params=new_pars, model=gsmar$model$model, restricted=gsmar$model$restricted,
constraints=constraints, conditional=gsmar$model$conditional, boundaries=TRUE, checks=FALSE, minval=NA)
}, numeric(1))
# In order to get the labels right, we first determine which parameter is in question.
# With constraints AR parameters are not phi-parameters! So different label.
if(restricted == FALSE) {
# phi and sigma^2 parameters
if(i1 <= max(cum_q)) {
m <- sum(i1 > cum_q) # Which regime are we considering
if(i1 == cum_q[m + 1]) { # sigma^2
main <- substitute(sigma[foo]^2, list(foo=paste0(m, ",", p))) # make square later
} else if(i1 <= sum(all_q) + M*2) { # phi_{m,0},...,phi_{m,p}
if(i1 == cum_q[m] + 1) { # phi_{m,0}
p0 <- 0
} else {
p0 <- i1 - cum_q[m] - 1 # p0 = 1,...,p, minus 1 from phi_0
}
main <- substitute(phi[foo], list(foo=paste0(m, ",", p0)))
} else { # alphas and degrees of freedom if any
}
}
} else { # restricted == TRUE
}
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
abline(v=pars[i1], col="red")
}
par(mar=c(2.1, 2.1, 1.6, 1.1), mfrow=c(nrows, ncols))
for(i1 in seq_len(npars)) { # Go though the parameters
pars <- params
range <- abs(scale*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=precission) # Loglik to be evaluated at these values of the parameter considered
logliks <- vapply(vals, function(val) {
new_pars <- pars
new_pars[i1] <- val # Change the single parameter value
loglikelihood_int(data=gsmar$data, p=p, M=M_orig, params=new_pars, model=gsmar$model$model, restricted=gsmar$model$restricted,
constraints=constraints, conditional=gsmar$model$conditional, boundaries=TRUE, checks=FALSE, minval=NA)
}, numeric(1))
# In order to get the labels right, we first determine which parameter is in question.
# With constraints AR parameters are not phi-parameters! So different label.
if(restricted == FALSE) {
# phi and sigma^2 parameters
if(i1 <= max(cum_q)) {
m <- sum(i1 > cum_q) # Which regime are we considering
if(i1 == cum_q[m + 1]) { # sigma^2
main <- substitute(sigma[foo]^2, list(foo=paste0(m, ",", p))) # make square later
} else if(i1 <= sum(all_q) + M*2) { # phi_{m,0},...,phi_{m,p}
if(i1 == cum_q[m] + 1) { # phi_{m,0}
p0 <- 0
} else {
p0 <- i1 - cum_q[m] - 1 # p0 = 1,...,p, minus 1 from phi_0
}
main <- substitute(phi[foo], list(foo=paste0(m, ",", p0)))
} else { # alphas and degrees of freedom if any
}
}
} else { # restricted == TRUE
}
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
abline(v=pars[i1], col="red")
}
for(i1 in seq_len(npars)) { # Go though the parameters
pars <- params
range <- abs(scale*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=precission) # Loglik to be evaluated at these values of the parameter considered
logliks <- vapply(vals, function(val) {
new_pars <- pars
new_pars[i1] <- val # Change the single parameter value
loglikelihood_int(data=gsmar$data, p=p, M=M_orig, params=new_pars, model=gsmar$model$model, restricted=gsmar$model$restricted,
constraints=constraints, conditional=gsmar$model$conditional, boundaries=TRUE, checks=FALSE, minval=NA)
}, numeric(1))
# In order to get the labels right, we first determine which parameter is in question.
# With constraints AR parameters are not phi-parameters! So different label.
if(restricted == FALSE) {
# phi and sigma^2 parameters
if(i1 <= max(cum_q)) {
m <- sum(i1 > cum_q) # Which regime are we considering
if(i1 == cum_q[m + 1]) { # sigma^2
main <- substitute(sigma[foo]^2, list(foo=paste0(m, ",", p)))
} else if(i1 <= sum(all_q) + M*2) { # phi_{m,0},...,phi_{m,p}
if(i1 == cum_q[m] + 1) { # phi_{m,0}
main <- substitute(varphi[foo], list(foo=paste0(m, ",", 0)))
} else {
p0 <- i1 - cum_q[m] - 1 # p0 = 1,...,p, minus 1 from phi_0
}
main <- substitute(phi[foo], list(foo=paste0(m, ",", p0)))
} else { # alphas and degrees of freedom if any
}
}
} else { # restricted == TRUE
}
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
abline(v=pars[i1], col="red")
}
substitute(phi[foo], list(foo=paste0(m, ",", 0))
)
substitute(substitute(phi[foo], list(foo=paste0(m, ",", 0))), list(phi=AR))
substitute(substitute(phi[foo], list(foo=paste0(m, ",", 0))), list(phi="AR"))
substitute(substitute(phi[foo], list(phi=phi, foo=paste0(m, ",", 0))), list(phi="AR"))
substitute(symb[foo], list(symb=phi, foo=paste0(m, ",", 0)))
substitute(symb[foo], list(symb="phi", foo=paste0(m, ",", 0)))
main <- substitute(substitute(phi[foo], list(foo=paste0(m, ",", 0))), list(phi="AR"))
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
substitute(phi[foo], list(foo=paste0(m, ",", p0)))
substitute(phi[foo], list(phi="AR", foo=paste0(m, ",", p0)))
main <- substitute(phi[foo], list(phi="AR", foo=paste0(m, ",", p0)))
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
par(mar=c(2.1, 2.1, 1.6, 1.1), mfrow=c(nrows, ncols))
for(i1 in seq_len(npars)) { # Go though the parameters
pars <- params
range <- abs(scale*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=precission) # Loglik to be evaluated at these values of the parameter considered
logliks <- vapply(vals, function(val) {
new_pars <- pars
new_pars[i1] <- val # Change the single parameter value
loglikelihood_int(data=gsmar$data, p=p, M=M_orig, params=new_pars, model=gsmar$model$model, restricted=gsmar$model$restricted,
constraints=constraints, conditional=gsmar$model$conditional, boundaries=TRUE, checks=FALSE, minval=NA)
}, numeric(1))
# In order to get the labels right, we first determine which parameter is in question.
if(restricted == FALSE) {
# phi and sigma^2 parameters
if(i1 <= max(cum_q)) {
m <- sum(i1 > cum_q) # Which regime are we considering
if(i1 == cum_q[m + 1]) { # sigma^2
main <- substitute(sigma[foo]^2, list(foo=paste0(m, ",", p)))
} else if(i1 <= sum(all_q) + M*2) { # phi_{m,0},...,phi_{m,p}
if(i1 == cum_q[m] + 1) { # phi_{m,0}
#main <- substitute(phi[foo], list(foo=paste0(m, ",", 0)))
mylist <- list(foo=paste0(m, ",", 0))
} else {
p0 <- i1 - cum_q[m] - 1 # p0 = 1,...,p, minus 1 from phi_0
if(is.null(constraints)) {
mylist  <- list(foo=paste0(m, ",", p0))
#main <- substitute(phi[foo], list(foo=paste0(m, ",", p0)))
} else {
# The AR parameters are not generally the same as phi-parameters with linear constraints
mylist  <- list(phi="AR", foo=paste0(m, ",", p0))
}
}
main <- substitute(phi[foo], mylist)
} else { # alphas and degrees of freedom if any
}
}
} else { # restricted == TRUE
}
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
abline(v=pars[i1], col="red")
}
for(i1 in seq_len(npars)) { # Go though the parameters
pars <- params
range <- abs(scale*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=precission) # Loglik to be evaluated at these values of the parameter considered
logliks <- vapply(vals, function(val) {
new_pars <- pars
new_pars[i1] <- val # Change the single parameter value
loglikelihood_int(data=gsmar$data, p=p, M=M_orig, params=new_pars, model=gsmar$model$model, restricted=gsmar$model$restricted,
constraints=constraints, conditional=gsmar$model$conditional, boundaries=TRUE, checks=FALSE, minval=NA)
}, numeric(1))
# In order to get the labels right, we first determine which parameter is in question.
if(restricted == FALSE) {
# phi and sigma^2 parameters
if(i1 <= max(cum_q)) {
m <- sum(i1 > cum_q) # Which regime are we considering
if(i1 == cum_q[m + 1]) { # sigma^2
main <- substitute(sigma[foo]^2, list(foo=paste0(m, ",", p)))
} else if(i1 <= sum(all_q) + M*2) { # phi_{m,0},...,phi_{m,p}
if(i1 == cum_q[m] + 1) { # phi_{m,0}
#main <- substitute(phi[foo], list(foo=paste0(m, ",", 0)))
mylist <- list(foo=paste0(m, ",", 0))
} else {
p0 <- i1 - cum_q[m] - 1 # p0 = 1,...,p, minus 1 from phi_0
if(!is.null(constraints)) {
mylist  <- list(foo=paste0(m, ",", p0))
#main <- substitute(phi[foo], list(foo=paste0(m, ",", p0)))
} else {
# The AR parameters are not generally the same as phi-parameters with linear constraints
mylist  <- list(phi="AR", foo=paste0(m, ",", p0))
}
}
main <- substitute(phi[foo], mylist)
} else { # alphas and degrees of freedom if any
}
}
} else { # restricted == TRUE
}
plot(x=vals, y=logliks, type="l", main=main)#main=substitute(Delta[foo], list(foo=paste0(m, ",", p))))
abline(v=pars[i1], col="red")
}
sum(all_q)
if(i1 <= sum(all_q) + M*2) { # The alphas first
}
sum(all_q) + M*2
max(cum_q)
M - 1
max(cum_q)
max(cum_q)
i1
i1 - max(cum_q)
- (M - 1)
(M - 1)
1 - 2 + 1
devtools::load_all()
plot_profile_logliks(fit12)
devtools::load_all()
devtools::load_all()
fit12
fit12$uncond_moments
fit12$model$constraints
devtools::load_all()
plot_profile_logliks(fit12)
devtools::load_all()
plot_profile_logliks(fit12)
devtools::load_all()
plot_profile_logliks(fit12)
devtools::load_all()
plot_profile_logliks(fit12)
