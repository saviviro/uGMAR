#par(mar=c(2.1, 2.6, 1.1, 2.6), mfrow=c(2, 1), las=1)
plot(FEDFUNDS, col="slateblue", lty=3, main="", ylab="", xlab="", xaxt="n", yaxt="n", ylim=c(0, 20))
layout(mat=matrix(c(1, 3, 2, 3), nrow=2, byrow=TRUE), widths=c(2, 1))
#par(mar=c(2.1, 2.6, 1.1, 2.6), mfrow=c(2, 1), las=1)
par(las=1)
plot(FEDFUNDS, col="slateblue", lty=3, main="", ylab="", xlab="", xaxt="n", yaxt="n", ylim=c(0, 20))
#axis(side=2, pos=1954, col.axis="slateblue", col.ticks="slateblue", col="slateblue", lty=1, font=2, cex.axis=0.8, xaxt="n")
segments(x0=rep(1950, 5), x1=rep(1953, 5), y0=seq(0, 20, by=5), col="slateblue")
text(x=rep(1955, 5), y=seq(0, 20, by=5), col="slateblue", labels=seq(0, 20, by=5), font=2, cex=0.8)
#axis(side=4, col.axis="coral", col.ticks="coral", col="slateblue", lty=3, font=2, cex.axis=0.8)
lines(TB3MS, col="coral", lty=3)
par(new=TRUE)
plot(YF, type="n", main="", ylab="", xlab="", xaxt="n", yaxt="n")
abline(h=0, col="grey", lty=2)
lines(YF)
axis(side=1, col.axis="black", col.ticks="black", col="black", at=seq(1960, 2020, by=10), lty=1, font=1, cex.axis=1)
axis(side=2, col.axis="black", col.ticks="black", col="black", lty=1, font=2, cex.axis=0.8)
#par(new=TRUE)
cols <- c("red3", "green3", "blue3") # coral, slateblue, orange, springgreen4
plot(ts(c(rep(NA, times=5), mod53$mixing_weights[,1]), start=c(1954, 7), frequency=12), type="l", col=cols[1], ylim=c(0, 1), lty=2, ylab=NA, xaxt="n", yaxt="n")
lines(ts(c(rep(NA, times=5), mod53$mixing_weights[,2]), start=c(1954, 7), frequency=12), col=cols[2], lty=2)
lines(ts(c(rep(NA, times=5), mod53$mixing_weights[,3]), start=c(1954, 7), frequency=12), col=cols[3], lty=2)
axis(side=2, col.axis="black", col.ticks="black", col="black", lty=1, font=2, cex.axis=0.8)
# mod53 density plot
x <- seq(-6, 2, by=0.01)
alphas <- pick_alphas(p=5, M=c(1, 2), params=mod53$params, model="G-StMAR")
means <- get_regime_means(mod53)
vars <- get_regime_vars(mod53)
dfs <- pick_dfs(p=5, M=c(1, 2), params=mod53$params, model="G-StMAR")
plot(density(YF), ylim=c(0, 2), main="", ylab="", xlab="")
lines(x=x, y=alphas[1]*dnorm(x, mean=means[1], sd=sqrt(vars[1])), type="l", lty=3, col=cols[1])
lines(x=x, y=alphas[2]*my_dt(x, mean=means[2], var=vars[2], df=dfs[1]), type="l", lty=3, col=cols[2])
lines(x=x, y=alphas[3]*my_dt(x, mean=means[3], var=vars[3], df=dfs[2]), type="l", lty=3, col=cols[3])
lines(x=x, y=mod53_dens(x), type="l", lty=2, col="red4")
layout(mat=matrix(c(1, 3, 2, 3), nrow=2, byrow=TRUE), widths=c(2, 1))
#par(mar=c(2.1, 2.6, 1.1, 2.6), mfrow=c(2, 1), las=1)
par(las=1, mar=c(2.1, 2.6, 1.1, 0.1))
plot(FEDFUNDS, col="slateblue", lty=3, main="", ylab="", xlab="", xaxt="n", yaxt="n", ylim=c(0, 20))
#axis(side=2, pos=1954, col.axis="slateblue", col.ticks="slateblue", col="slateblue", lty=1, font=2, cex.axis=0.8, xaxt="n")
segments(x0=rep(1950, 5), x1=rep(1953, 5), y0=seq(0, 20, by=5), col="slateblue")
text(x=rep(1955, 5), y=seq(0, 20, by=5), col="slateblue", labels=seq(0, 20, by=5), font=2, cex=0.8)
#axis(side=4, col.axis="coral", col.ticks="coral", col="slateblue", lty=3, font=2, cex.axis=0.8)
lines(TB3MS, col="coral", lty=3)
#abline(h=0, col="grey", lty=1)
par(new=TRUE)
plot(YF, type="n", main="", ylab="", xlab="", xaxt="n", yaxt="n")
abline(h=0, col="grey", lty=2)
lines(YF)
axis(side=1, col.axis="black", col.ticks="black", col="black", at=seq(1960, 2020, by=10), lty=1, font=1, cex.axis=1)
axis(side=2, col.axis="black", col.ticks="black", col="black", lty=1, font=2, cex.axis=0.8)
#par(new=TRUE)
cols <- c("red3", "green3", "blue3") # coral, slateblue, orange, springgreen4
plot(ts(c(rep(NA, times=5), mod53$mixing_weights[,1]), start=c(1954, 7), frequency=12), type="l", col=cols[1], ylim=c(0, 1), lty=2, ylab=NA, xaxt="n", yaxt="n")
lines(ts(c(rep(NA, times=5), mod53$mixing_weights[,2]), start=c(1954, 7), frequency=12), col=cols[2], lty=2)
lines(ts(c(rep(NA, times=5), mod53$mixing_weights[,3]), start=c(1954, 7), frequency=12), col=cols[3], lty=2)
axis(side=2, col.axis="black", col.ticks="black", col="black", lty=1, font=2, cex.axis=0.8)
#axis(side=1, col.axis="black", col.ticks="black", col="black", at=seq(1960, 2020, by=10), labels=NA, lty=1, font=1, cex.axis=1)
# mod53 density plot
x <- seq(-6, 2, by=0.01)
alphas <- pick_alphas(p=5, M=c(1, 2), params=mod53$params, model="G-StMAR")
means <- get_regime_means(mod53)
vars <- get_regime_vars(mod53)
dfs <- pick_dfs(p=5, M=c(1, 2), params=mod53$params, model="G-StMAR")
plot(density(YF), ylim=c(0, 2), main="", ylab="", xlab="")
lines(x=x, y=alphas[1]*dnorm(x, mean=means[1], sd=sqrt(vars[1])), type="l", lty=3, col=cols[1])
lines(x=x, y=alphas[2]*my_dt(x, mean=means[2], var=vars[2], df=dfs[1]), type="l", lty=3, col=cols[2])
lines(x=x, y=alphas[3]*my_dt(x, mean=means[3], var=vars[3], df=dfs[2]), type="l", lty=3, col=cols[3])
lines(x=x, y=mod53_dens(x), type="l", lty=2, col="red4")
layout(mat=matrix(c(1, 3, 2, 3), nrow=2, byrow=TRUE), widths=c(2, 1))
#par(mar=c(2.1, 2.6, 1.1, 2.6), mfrow=c(2, 1), las=1)
par(las=1, mar=c(2.1, 2.6, 1.1, 1.1))
plot(FEDFUNDS, col="slateblue", lty=3, main="", ylab="", xlab="", xaxt="n", yaxt="n", ylim=c(0, 20))
#axis(side=2, pos=1954, col.axis="slateblue", col.ticks="slateblue", col="slateblue", lty=1, font=2, cex.axis=0.8, xaxt="n")
segments(x0=rep(1950, 5), x1=rep(1953, 5), y0=seq(0, 20, by=5), col="slateblue")
text(x=rep(1955, 5), y=seq(0, 20, by=5), col="slateblue", labels=seq(0, 20, by=5), font=2, cex=0.8)
#axis(side=4, col.axis="coral", col.ticks="coral", col="slateblue", lty=3, font=2, cex.axis=0.8)
lines(TB3MS, col="coral", lty=3)
#abline(h=0, col="grey", lty=1)
par(new=TRUE)
plot(YF, type="n", main="", ylab="", xlab="", xaxt="n", yaxt="n")
abline(h=0, col="grey", lty=2)
lines(YF)
axis(side=1, col.axis="black", col.ticks="black", col="black", at=seq(1960, 2020, by=10), lty=1, font=1, cex.axis=1)
axis(side=2, col.axis="black", col.ticks="black", col="black", lty=1, font=2, cex.axis=0.8)
#par(new=TRUE)
cols <- c("red3", "green3", "blue3") # coral, slateblue, orange, springgreen4
plot(ts(c(rep(NA, times=5), mod53$mixing_weights[,1]), start=c(1954, 7), frequency=12), type="l", col=cols[1], ylim=c(0, 1), lty=2, ylab=NA, xaxt="n", yaxt="n")
lines(ts(c(rep(NA, times=5), mod53$mixing_weights[,2]), start=c(1954, 7), frequency=12), col=cols[2], lty=2)
lines(ts(c(rep(NA, times=5), mod53$mixing_weights[,3]), start=c(1954, 7), frequency=12), col=cols[3], lty=2)
axis(side=2, col.axis="black", col.ticks="black", col="black", lty=1, font=2, cex.axis=0.8)
#axis(side=1, col.axis="black", col.ticks="black", col="black", at=seq(1960, 2020, by=10), labels=NA, lty=1, font=1, cex.axis=1)
# mod53 density plot
x <- seq(-6, 2, by=0.01)
alphas <- pick_alphas(p=5, M=c(1, 2), params=mod53$params, model="G-StMAR")
means <- get_regime_means(mod53)
vars <- get_regime_vars(mod53)
dfs <- pick_dfs(p=5, M=c(1, 2), params=mod53$params, model="G-StMAR")
plot(density(YF), ylim=c(0, 2), main="", ylab="", xlab="")
lines(x=x, y=alphas[1]*dnorm(x, mean=means[1], sd=sqrt(vars[1])), type="l", lty=3, col=cols[1])
lines(x=x, y=alphas[2]*my_dt(x, mean=means[2], var=vars[2], df=dfs[1]), type="l", lty=3, col=cols[2])
lines(x=x, y=alphas[3]*my_dt(x, mean=means[3], var=vars[3], df=dfs[2]), type="l", lty=3, col=cols[3])
lines(x=x, y=mod53_dens(x), type="l", lty=2, col="red4")
layout(mat=matrix(c(1, 3, 2, 3), nrow=2, byrow=TRUE), widths=c(2, 1))
#par(mar=c(2.1, 2.6, 1.1, 2.6), mfrow=c(2, 1), las=1)
par(las=1, mar=c(2.1, 2.6, 1.1, 1.1))
plot(FEDFUNDS, col="slateblue", lty=3, main="", ylab="", xlab="", xaxt="n", yaxt="n", ylim=c(0, 20))
#axis(side=2, pos=1954, col.axis="slateblue", col.ticks="slateblue", col="slateblue", lty=1, font=2, cex.axis=0.8, xaxt="n")
segments(x0=rep(1950, 5), x1=rep(1953, 5), y0=seq(0, 20, by=5), col="slateblue")
text(x=rep(1955, 5), y=seq(0, 20, by=5), col="slateblue", labels=seq(0, 20, by=5), font=2, cex=0.8)
#axis(side=4, col.axis="coral", col.ticks="coral", col="slateblue", lty=3, font=2, cex.axis=0.8)
lines(TB3MS, col="coral", lty=3)
#abline(h=0, col="grey", lty=1)
par(new=TRUE)
plot(YF, type="n", main="", ylab="", xlab="", xaxt="n", yaxt="n")
abline(h=0, col="grey", lty=2)
lines(YF)
axis(side=1, col.axis="black", col.ticks="black", col="black", at=seq(1960, 2020, by=10), lty=1, font=1, cex.axis=1)
axis(side=2, col.axis="black", col.ticks="black", col="black", lty=1, font=2, cex.axis=0.8)
#par(new=TRUE)
cols <- c("red3", "green3", "blue3") # coral, slateblue, orange, springgreen4
plot(ts(c(rep(NA, times=5), mod53$mixing_weights[,1]), start=c(1954, 7), frequency=12), type="l", col=cols[1], ylim=c(0, 1), lty=2, ylab=NA, xaxt="n", yaxt="n")
lines(ts(c(rep(NA, times=5), mod53$mixing_weights[,2]), start=c(1954, 7), frequency=12), col=cols[2], lty=2)
lines(ts(c(rep(NA, times=5), mod53$mixing_weights[,3]), start=c(1954, 7), frequency=12), col=cols[3], lty=2)
axis(side=2, col.axis="black", col.ticks="black", col="black", lty=1, font=2, cex.axis=0.8)
#axis(side=1, col.axis="black", col.ticks="black", col="black", at=seq(1960, 2020, by=10), labels=NA, lty=1, font=1, cex.axis=1)
# mod53 density plot
x <- seq(-6, 2, by=0.01)
alphas <- pick_alphas(p=5, M=c(1, 2), params=mod53$params, model="G-StMAR")
means <- get_regime_means(mod53)
vars <- get_regime_vars(mod53)
dfs <- pick_dfs(p=5, M=c(1, 2), params=mod53$params, model="G-StMAR")
plot(density(YF), ylim=c(0, 2), main="", ylab="", xlab="", cex.axis=0.8, font.axis=2)
lines(x=x, y=alphas[1]*dnorm(x, mean=means[1], sd=sqrt(vars[1])), type="l", lty=3, col=cols[1])
lines(x=x, y=alphas[2]*my_dt(x, mean=means[2], var=vars[2], df=dfs[1]), type="l", lty=3, col=cols[2])
lines(x=x, y=alphas[3]*my_dt(x, mean=means[3], var=vars[3], df=dfs[2]), type="l", lty=3, col=cols[3])
lines(x=x, y=mod53_dens(x), type="l", lty=2, col="red4")
save.image("\\\\ad.helsinki.fi/home/s/saviviro/Desktop/GSTMARartikkeli/empexample_env_vara")
mods2 <- lapply(1:6, function(i1) fitGSMAR(YF, p=i1, M=2, model="StMAR", conditional=FALSE, ncalls=100, ncores=4, seeds=1:100)) # AIC p=6, HQIC p=5, BIC p=5
save.image("\\\\ad.helsinki.fi/home/s/saviviro/Desktop/GSTMARartikkeli/empexample_env")
mods3 <- lapply(1:6, function(i1) fitGSMAR(YF, p=i1, M=3, model="StMAR", conditional=FALSE, ncalls=100, ncores=4, seeds=1:100)) # AIC p=3, HQIC p=3, BIC p=3
save.image("\\\\ad.helsinki.fi/home/s/saviviro/Desktop/GSTMARartikkeli/empexample_env")
gmars4 <- lapply(1:6, function(i1) fitGSMAR(YF, p=i1, M=4, model="GMAR", conditional=FALSE, ncalls=100, ncores=4, seeds=1:100))
save.image("\\\\ad.helsinki.fi/home/s/saviviro/Desktop/GSTMARartikkeli/empexample_env")
gmars4[[3]]$IC
plot(gmars4[[3]])
diagnosticPlot(gmars4[[3]])
diagnosticPlot(gmars4[[4]])
diagnosticPlot(gmars4[[6]])
plot(gmars4[[6]])
quantileResidualTests(gmars4[[6]])
length(gmars4[[6]]$params)
length(gmars4[[3]]$params)
quantileResidualTests(gmars4[[3]])
quantileResidualTests(gmars4[[5]])
gmars4[[5]]$IC
plot(gmars4[[5]])
summary(gmars4[[5]])
diagnosticPlot(gmars4[[5]])
length(gmars4[[5]]$params)
length(mod53$params)
sapply(1:6, function(i1) gmars4[[i1]]$loglik) # loglik p=6 (249.7902), AIC p=6 (-447.5804), HQIC p=2 (-427.6772), BIC p=2 (-387.5229)
sapply(1:6, function(i1) gmars4[[i1]]$IC) # loglik p=5 (317.0821), AIC p=6 (-447.5804), HQIC p=2 (-427.6772), BIC p=2 (-387.5229)
mod54g <- gmars4[[5]]
get_foc(mod54g)
get_soc(mod54g)
qrt53g <- quantileResidualTests(gmars4[[5]], lagsAC=c(1, 3, 6, 12), nsimu=20000)
qrt53g <- quantileResidualTests(gmars4[[5]], lagsAC=c(1, 3, 6, 12), nsimu=20000)
qrt54g <- rt53g
qrt54g <- qrt53g
# Choose the best M=2 model:
sapply(1:6, function(i1) mods2[[i1]]$IC) # max: loglik p=6 (312.5191), AIC p=6 (-587.0383), HQIC p=5 (-553.8559), BIC p=5 (-505.0972)
summary(mods2[[6]], digits=6) # Check p=6 estimate
get_foc(mods2[[6]]); get_soc(mods2[[6]]) # FOC ok, SOC ok
plot(mods2[[6]])
summary(mods2[[5]], digits=6) # Check p=5 estimate: overly large degrees of freedom
mod52 <- stmar_to_gstmar(mods2[[5]]) # Swap to G-StMAR model
get_foc(mod52); get_soc(mod52) # SOC ok. FOC ok but some large values; however, profile log-likelihoods confirm approximate maximum
plot(mod52)
# Prof-log-lik
par(mar=c(2.1, 1, 1, 1), mfrow=c(4, 4))
for(i1 in 1:16) {
pars <- mod52$params
range <- abs(0.02*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=100)
logliks <- vapply(vals, function(new_val) {
new_pars <- pars
new_pars[i1] <- new_val
loglikelihood_int(data=YF, p=5, M=c(1, 1), params=new_pars, model="G-StMAR", conditional=FALSE, boundaries=TRUE, minval=NA)
}, numeric(1))
plot(x=vals, y=logliks, type="l"); abline(v=pars[i1], col="red")
}
sapply(1:6, function(i1) mods3[[i1]]$IC) #IC mins are: AIC p=6 (-604.466), HQIC p=6 (-552.486), BIC p=5 (-471.0669)
summary(mods3[[6]], digits=6) # Check first the p=6 estimate: third regime really close the border of the stationarity region
get_foc(mods3[[6]]); get_soc(mods3[[6]])  # Large values in FOC, SOC ok.
plot(mods3[[6]]) # Second regime seems a bit problematic. This model is similar to the 2-regime model but with additional
mods3[[6]]
length(mods3[[6]]$params)
#########################################################
######## Profile log-likelihoods ########################
#old_par <- par()
par(mar=c(2.1, 1, 1, 1), mfrow=c(6, 5))
p <- 6
M <- 3#c(1, 2)
for(i1 in 1:29) {
pars <- mods3[[p]]$params
#pars <- mod53$params
range <- abs(0.02*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=100)
logliks <- vapply(vals, function(new_val) {
new_pars <- pars
new_pars[i1] <- new_val
loglikelihood_int(data=YF, p=p, M=M, params=new_pars, model="G-StMAR", conditional=FALSE, boundaries=TRUE, minval=NA)
}, numeric(1))
plot(x=vals, y=logliks, type="l"); abline(v=pars[i1], col="red")
}
for(i1 in 1:29) {
pars <- mods3[[p]]$params
#pars <- mod53$params
range <- abs(0.02*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=100)
logliks <- vapply(vals, function(new_val) {
new_pars <- pars
new_pars[i1] <- new_val
loglikelihood_int(data=YF, p=p, M=M, params=new_pars, model="StMAR", conditional=FALSE, boundaries=TRUE, minval=NA)
}, numeric(1))
plot(x=vals, y=logliks, type="l"); abline(v=pars[i1], col="red")
}
# Check the second highest log-likelihood:
order(mods3[[6]]$all_logliks, decreasing=TRUE) # 99th:th estimation round
mod63_2 <- alt_gsmar(mods3[[6]], 99)
summary(mod63_2, digits=6) # 3rd regime near boundary of stationarity region
plot(mod63_2g) # For the same reasons as in the previous case, this estimate is not an appropriate solution for the model
plot(mod63_2) # For the same reasons as in the previous case, this estimate is not an appropriate solution for the model
# Check the third highest log-likelihood
order(mods3[[6]]$all_logliks, decreasing=TRUE) # 31:th estimation round has the third best loglik
mod63_3 <- alt_gsmar(mods3[[6]], 31)
summary(mod63_3, digits=6) # The second regime seems to have 4 close-to-unit-roots: again this is not
plot(mod63_3) # an appropriate solution for the model.
mod63_3$IC # The AIC is -591.6097 , HQIC -539.6298 and BIC -456.453 which is worse than in the p=5 case,
sapply(1:6, function(i1) mods3[[i1]]$IC) #IC mins are: AIC p=6 (-604.466), HQIC p=6 (-552.486), BIC p=5 (-471.0667)
# Check the fourth highest log-likelihood
order(mods3[[6]]$all_logliks, decreasing=TRUE) # 31:th estimation round has the third best loglik
mod63_4 <- alt_gsmar(mods3[[6]], 66)
summary(mod63_4, digits=6) # The second regime seems to have 4 close-to-unit-roots: again this is not
get_foc(mod63_4)
get_soc(mod63_4)
plot(mod63_4)
mod63_4$IC
mods3[[5]]$IC
# Check the p=5 case:
summary(mods3[[5]], digits=6) # No unit roots, high degree of freedom and small variance in the third regime.
mod53 <- stmar_to_gstmar(mods3[[5]]) # Swap to G-StMAR model
get_foc(mod53); get_soc(mod53) # SOC ok, FOC has large value for the small var param, but profile log-likelihoods confirm that the
# the estimate points a maximum point and the high FOC value is just due to error in the numerical approximation.
par(mar=c(2.1, 1, 1, 1), mfrow=c(6, 5))
for(i1 in 1:29) {
pars <- mod53$params
range <- abs(0.02*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=100)
logliks <- vapply(vals, function(new_val) {
new_pars <- pars
new_pars[i1] <- new_val
loglikelihood_int(data=YF, p=5, M=c(1, 2), params=new_pars, model="G-StMAR", conditional=FALSE, boundaries=TRUE, minval=NA)
}, numeric(1))
plot(x=vals, y=logliks, type="l"); abline(v=pars[i1], col="red")
}
length(pars)
# the estimate points a maximum point and the high FOC value is just due to error in the numerical approximation.
par(mar=c(2.1, 1, 1, 1), mfrow=c(5, 5))
for(i1 in 1:25) {
pars <- mod53$params
range <- abs(0.02*pars[i1])
vals <- seq(from=pars[i1] - range, to=pars[i1] + range, length.out=100)
logliks <- vapply(vals, function(new_val) {
new_pars <- pars
new_pars[i1] <- new_val
loglikelihood_int(data=YF, p=5, M=c(1, 2), params=new_pars, model="G-StMAR", conditional=FALSE, boundaries=TRUE, minval=NA)
}, numeric(1))
plot(x=vals, y=logliks, type="l"); abline(v=pars[i1], col="red")
}
plot(YF)
par(old_par)
plot(YF)
pacf(YF)
pacf(YF^2)
loks <- vapply(1:24, function(i1) mods1[[i1]]$loglik, numeric(1))
aics <- vapply(1:24, function(i1) mods1[[i1]]$IC$AIC, numeric(1))
hqics <- vapply(1:24, function(i1) mods1[[i1]]$IC$HQIC, numeric(1))
bics <- vapply(1:24, function(i1) mods1[[i1]]$IC$BIC, numeric(1))
plot(loks, type="b", ylim=c(150, 550))
lines(-aics, type="b", col="red")
lines(-hqics, type="b", col="blue")
lines(-bics, type="b", col="green")
abline(v=6)
qrt61
diagnosticPlot(mods1[[6]])
qrt61 <- quantileResidualTests(YF61, lagsAC=c(1, 3, 6, 12), nsimu=2000)
summary(mods2[[6]], digits=6) # Check p=6 estimate
summary(mods2[[6]], digits=2) # Check p=6 estimate
summary(mods2[[5]], digits=2) # Check p=6 estimate
plot(mod52)
diagnosticPlot(mod52)
qrt52
mods2[[5]]
summary(mods3[[6]], digits=2) # Check first the p=6 estimate: third regime really close the border of the stationarity region
plot(mods3[[6]]) # Second regime seems problematic. This model is similar to the 2-regime model but with additional
plot(mod63_4)
layout(mat=matrix(c(1, 3, 2, 3), nrow=2, byrow=TRUE), widths=c(2, 1))
#par(mar=c(2.1, 2.6, 1.1, 2.6), mfrow=c(2, 1), las=1)
par(las=1, mar=c(2.1, 2.6, 1.1, 1.1))
plot(FEDFUNDS, col="slateblue", lty=3, main="", ylab="", xlab="", xaxt="n", yaxt="n", ylim=c(0, 20))
#axis(side=2, pos=1954, col.axis="slateblue", col.ticks="slateblue", col="slateblue", lty=1, font=2, cex.axis=0.8, xaxt="n")
segments(x0=rep(1950, 5), x1=rep(1953, 5), y0=seq(0, 20, by=5), col="slateblue")
text(x=rep(1955, 5), y=seq(0, 20, by=5), col="slateblue", labels=seq(0, 20, by=5), font=2, cex=0.8)
#axis(side=4, col.axis="coral", col.ticks="coral", col="slateblue", lty=3, font=2, cex.axis=0.8)
lines(TB3MS, col="coral", lty=3)
#abline(h=0, col="grey", lty=1)
par(new=TRUE)
plot(YF, type="n", main="", ylab="", xlab="", xaxt="n", yaxt="n")
abline(h=0, col="grey", lty=2)
lines(YF)
axis(side=1, col.axis="black", col.ticks="black", col="black", at=seq(1960, 2020, by=10), lty=1, font=1, cex.axis=1)
axis(side=2, col.axis="black", col.ticks="black", col="black", lty=1, font=2, cex.axis=0.8)
#par(new=TRUE)
cols <- c("red3", "green3", "blue3") # coral, slateblue, orange, springgreen4
plot(ts(c(rep(NA, times=5), mod53$mixing_weights[,1]), start=c(1954, 7), frequency=12), type="l", col=cols[1], ylim=c(0, 1), lty=2, ylab=NA, xaxt="n", yaxt="n")
lines(ts(c(rep(NA, times=5), mod53$mixing_weights[,2]), start=c(1954, 7), frequency=12), col=cols[2], lty=2)
lines(ts(c(rep(NA, times=5), mod53$mixing_weights[,3]), start=c(1954, 7), frequency=12), col=cols[3], lty=2)
axis(side=2, col.axis="black", col.ticks="black", col="black", lty=1, font=2, cex.axis=0.8)
#axis(side=1, col.axis="black", col.ticks="black", col="black", at=seq(1960, 2020, by=10), labels=NA, lty=1, font=1, cex.axis=1)
# LAITA DENSITYN TICKIT KUVAN SISÄÄN TMS? JA SÄÄDÄ SLATEBLUE TICKKIEN KOKO?
# mod53 density plot
x <- seq(-6, 2, by=0.01)
alphas <- pick_alphas(p=5, M=c(1, 2), params=mod53$params, model="G-StMAR")
means <- get_regime_means(mod53)
vars <- get_regime_vars(mod53)
dfs <- pick_dfs(p=5, M=c(1, 2), params=mod53$params, model="G-StMAR")
plot(density(YF), ylim=c(0, 2), main="", ylab="", xlab="", cex.axis=0.8, font.axis=2)
lines(x=x, y=alphas[1]*dnorm(x, mean=means[1], sd=sqrt(vars[1])), type="l", lty=3, col=cols[1])
lines(x=x, y=alphas[2]*my_dt(x, mean=means[2], var=vars[2], df=dfs[1]), type="l", lty=3, col=cols[2])
lines(x=x, y=alphas[3]*my_dt(x, mean=means[3], var=vars[3], df=dfs[2]), type="l", lty=3, col=cols[3])
lines(x=x, y=mod53_dens(x), type="l", lty=2, col="red4")
1
devtools::test())
devtools::test()
devtools::test()
params11t <- c(-2, 0.8, 1, 12)
params12 <- c(1.1, 0.9, 0.29, 4.5, 0.7, 3.2, 0.8)
params23t <- c(1.8, 0.9, -0.06, 0.4, 7.2, 0.3, -0.009, 0.1, 3.1, 0.83, -0.05, 3.7, 0.7, 0.2, 11, 339, 198)
params12r <- c(1, 4, 0.8, 0.3, 3, 0.8)
params12gs <- c(1.2, 0.8, 0.6, 1.3, 0.6, 1.1, 0.6, 3) # M1=1, M2=1
params13gsr <- c(1.3, 2.2, 1.4, 0.8, 2.4, 4.6, 0.4, 0.25, 0.15, 20) # M1=2, M2=1
g_norm <- function(r) cbind(r^2-1, r^3, r^4-3)
omega_n11t <- getOmega(VIX, 1, 1, params11t, model="StMAR", g=g_norm, dim_g=3)
omega_n12 <- getOmega(VIX, 1, 2, params12, g=g_norm, dim_g=3)
omega_n11t[2, ]
omega_n23t <- getOmega(VIX, 2, 3, params23t, model="StMAR", g=g_norm, dim_g=3)
omega_n23t[3, 2]
devtools::test()
devtools::test()
devtools::document()
devtools::test()
# These are long running examples that use parallel computing
# GMAR model
fit12 <- fitGSMAR(data=logVIX, p=1, M=2, model="GMAR")
fit12
summary(fit12)
plot(fit12)
# Restricted GMAR model
fit12r <- fitGSMAR(logVIX, 1, 2, model="GMAR", restricted=TRUE,
parametrization="mean", ncalls=10)
fit12r
summary(fit12r)
# Non-mixture version of StMAR model
fit11t <- fitGSMAR(logVIX, 1, 1, model="StMAR", ncores=1, ncalls=1)
fit11t
# StMAR model, seeds for reproducability
fit12t <- fitGSMAR(logVIX, 1, 2, model="StMAR", ncalls=10,
seeds=1:10)
fit12t
# G-StMAR model with one GMAR type and one StMAR type regime
fit12gs <- fitGSMAR(logVIX, 1, M=c(1, 1), model="G-StMAR")
fit12gs
# Restricted G-StMAR model
fit12gsr <- fitGSMAR(logVIX, 1, c(1, 1), model="G-StMAR", restricted=TRUE)
fit12gsr
# The following three examples demonstrate how to apply linear constraints
# to the AR parameters.
# GMAR(p=3, M=2) model that the second and third AR coefficients are constrained
# to zero in the first regime, and the second AR coefficient is constrained to
# zero in the second regime.
constraints <- list(matrix(c(1, 0, 0, 0, 0, 1), ncol=2), as.matrix(c(1, 0, 0)))
fit32c <- fitGSMAR(logVIX, 3, 2, constraints=constraints)
fit32c
# Such constrained StMAR(3, 1) model that the second order AR coefficient
# is constrained to zero.
constraints <- list(matrix(c(1, 0, 0, 0, 0, 1), ncol=2))
fit31tc <- fitGSMAR(logVIX, 3, 1, model="StMAR", constraints=constraints)
fit31tc
# Such StMAR(3, 2) model that the AR coefficients are restricted to be
# the same for both regimes and that the second AR coefficients are
# constrained to zero.
fit32trc <- fitGSMAR(logVIX, 3, 2, model="StMAR", restricted=TRUE,
constraints=matrix(c(1, 0, 0, 0, 0, 1), ncol=2))
fit32trc
qrtest12 <- quantileResidualTests(fit12)
qrtest12r <- quantileResidualTests(fit12r, lagsAC=1:10, nsimu=1)
quantileResidualTests(fit11t, lagsAC=c(1, 2, 5), nsimu=1, printRes=FALSE)
quantileResidualTests(fit12gs, lagsAC=c(1, 3), lagsCH=1:2,
nsimu=1, printRes=FALSE)
quantileResidualTests(fit22c, lagsAC=c(1, 3), nsimu=1, printRes=FALSE)
constraints <- list(diag(1, ncol=2, nrow=2), as.matrix(c(1, 0)))
fit22c <- fitGSMAR(logVIX, 2, 2, constraints=constraints)
quantileResidualTests(fit22c, lagsAC=c(1, 3), nsimu=1, printRes=FALSE)
fit12 <- fitGSMAR(logVIX, 1, 2, maxit=1, ngen=50, ncalls=3)
fit12
fit12 <- iterate_more(fit12)
fit12
fit12 <- fitGSMAR(logVIX, 1, 2, maxit=1, ngen=50, ncalls=1)
fit12 <- fitGSMAR(logVIX, 1, 2, maxit=1, ngen=50, ncalls=1, seeds=1)
fit12
fit12 <- iterate_more(fit12)
fit12
params12 <- c(0.18, 0.93, 0.01, 0.86, 0.68, 0.02, 0.88)
gmar12 <- GSMAR(data=logVIX, p=1, M=2, params=params12, model="GMAR")
gmar12
params12r <- c(0.21, 0.23, 0.92, 0.01, 0.02, 0.86)
gmar12r <- GSMAR(data=logVIX, p=1, M=2, params=params12r, model="GMAR",
restricted=TRUE)
gmar12r
params12t <- c(1.38, 0.88, 0.27, 3.8, 0.74, 3.15, 0.8, 300, 3.6)
stmar12t <- GSMAR(p=1, M=2, params=params12t, model="StMAR")
stmar12t
params12gs <- c(1.38, 0.88, 0.27, 3.8, 0.74, 3.15, 0.8, 3.6)
gstmar12 <- GSMAR(p=1, M=c(1, 1), params=params12gs, model="G-StMAR")
gstmar12
params12gsr <- c(0.31, 0.33, 0.88, 0.01, 0.02, 0.77, 2.72)
gstmar12r <- GSMAR(data=logVIX, p=1, M=c(1, 1), params=params12gsr,
model="G-StMAR", restricted=TRUE)
gstmar12r
constraints <- list(diag(1, ncol=2, nrow=2), as.matrix(c(1, 0)))
params22c <- c(0.61, 0.83, -0.06, 0.02, 0.21, 0.91, 0.01, 0.16)
gmar22c <- GSMAR(logVIX, p=2, M=2, params=params22c,
model="GMAR", constraints=constraints)
gmar22c
params32trc <- c(0.35, 0.33, 0.88, -0.02, 0.01, 0.01, 0.36, 4.53, 1000)
stmar32rc <- GSMAR(logVIX, p=3, M=2, params=params32trc, model="StMAR",
restricted=TRUE, constraints=matrix(c(1, 0, 0, 0, 0, 1), ncol=2))
stmar32rc
paramsHAR <- c(1, 0.1, 0.2, 0.3, 1, 2, 0.15, 0.25, 0.35, 2, 0.55)
r1 = c(1, rep(0, 21)); r2 = c(rep(0.2, 5), rep(0, 17)); r3 = rep(1/22, 22)
R0 = cbind(r1, r2, r3)
mixhar <- GSMAR(p=22, M=2, params=paramsHAR, model="GMAR", constraints=list(R0, R0))
mixhar
summary(mixhar)
summary(fit12)
foo <- function(x) x^2 + x
calc_gradient(x=1, fn=foo)
calc_gradient(x=-0.5, fn=foo)
calc_hessian(x=c(1, 2), fn=foo)
fn=foo
x=c(1,2)
n <- length(x)
I <- diag(1, nrow=n, ncol=n)
h <- rep(h, times=n)
Hess <- matrix(ncol=n, nrow=n)
for(i1 in 1:n) {
for(i2 in i1:n) {
dr1 <- (fn(x + h[i1]*I[i1,] + h[i2]*I[i2,], ...) - fn(x - h[i1]*I[i1,] + h[i2]*I[i2,], ...))/(2*h[i1])
dr2 <- (fn(x + h[i1]*I[i1,] - h[i2]*I[i2,], ...) - fn(x - h[i1]*I[i1,] - h[i2]*I[i2,], ...))/(2*h[i1])
Hess[i1, i2] <- (dr1 - dr2)/(2*h[i2])
Hess[i2, i1] <- Hess[i1, i2] # Take use of symmetry
}
}
h=6e-06
h <- rep(h, times=n)
for(i1 in 1:n) {
for(i2 in i1:n) {
dr1 <- (fn(x + h[i1]*I[i1,] + h[i2]*I[i2,], ...) - fn(x - h[i1]*I[i1,] + h[i2]*I[i2,], ...))/(2*h[i1])
dr2 <- (fn(x + h[i1]*I[i1,] - h[i2]*I[i2,], ...) - fn(x - h[i1]*I[i1,] - h[i2]*I[i2,], ...))/(2*h[i1])
Hess[i1, i2] <- (dr1 - dr2)/(2*h[i2])
Hess[i2, i1] <- Hess[i1, i2] # Take use of symmetry
}
}
calc_hessian(x=c(1, 2), fn=foo)
calc_hessian(x=2, fn=foo)
foo <- function(x, a, b) a*x[1]^2 - b*x[2]^2
calc_gradient(x=c(1, 2), fn=foo, a=0.3, b=0.1)
calc_hessian(x=c(1, 2), fn=foo, a=0.3, b=0.1)
params12 <- c(0.18281409, 0.92657275, 0.00214552,
0.85725129, 0.68210294, 0.01900299, 0.88342018)
gmar12 <- GSMAR(logVIX, 1, 2, params12)
get_gradient(gmar12)
get_foc(gmar12)
get_hessian(gmar12)
get_soc(gmar12)
devtools::build()
get_regime_vars(fit12)
print(fit12, summary_print = T)
summary(fit12t)
devtools::load_all()
summary(fit12t)
devtools::load_all()
summary(fit12t)
devtools::load_all()
devtools::document()
devtools::build()
devtools::release()
devtools::spell_check()
devtools::document()
devtools::release()
devtools::release()
